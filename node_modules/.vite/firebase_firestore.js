import {
  Component,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  deepEqual,
  getApp,
  getModularInstance,
  getUA,
  isBrowserExtension,
  isElectron,
  isIE,
  isIndexedDBAvailable,
  isMobileCordova,
  isReactNative,
  isSafari,
  isUWP,
  registerVersion
} from "./chunk-ZEKLCDYA.js";
import "./chunk-OF7PY2J2.js";

// node_modules/@firebase/webchannel-wrapper/dist/index.esm2017.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var esm = {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b = typeof a;
  b = b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return b == "array" || b == "object" && typeof a.length == "number";
}
function p(a) {
  var b = typeof a;
  return b == "object" && a != null || b == "function";
}
function da(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
var fa = 0;
function ha(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ia(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function q(a, b, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q = ha : q = ia;
  return q.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.Z = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ka = 0;
var la = {};
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), ka != 0)) {
    var a = da(this);
    delete la[a];
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var ma = Array.prototype.indexOf ? function(a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function(a, b) {
  if (typeof a === "string")
    return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
  for (let c = 0; c < a.length; c++)
    if (c in a && a[c] === b)
      return c;
  return -1;
};
var na = Array.prototype.forEach ? function(a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function(a, b, c) {
  const d = a.length, e = typeof a === "string" ? a.split("") : a;
  for (let f = 0; f < d; f++)
    f in e && b.call(c, e[f], f, a);
};
function oa(a) {
  a: {
    var b = pa;
    const c = a.length, d = typeof a === "string" ? a.split("") : a;
    for (let e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  const b = a.length;
  if (0 < b) {
    const c = Array(b);
    for (let d = 0; d < b; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function w(a, b) {
  return a.indexOf(b) != -1;
}
function ua(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var x;
a: {
  va2 = l.navigator;
  if (va2) {
    wa2 = va2.userAgent;
    if (wa2) {
      x = wa2;
      break a;
    }
  }
  x = "";
}
var va2;
var wa2;
function xa(a, b, c) {
  for (const d in a)
    b.call(c, a[d], d, a);
}
function ya(a) {
  const b = {};
  for (const c in a)
    b[c] = a[c];
  return b;
}
var za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Aa(a, b) {
  let c, d;
  for (let e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (let f = 0; f < za.length; f++)
      c = za[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ca(a) {
  Ca[" "](a);
  return a;
}
Ca[" "] = aa;
function Fa(a) {
  var b = Ga;
  return Object.prototype.hasOwnProperty.call(b, 9) ? b[9] : b[9] = a(9);
}
var Ha = w(x, "Opera");
var y = w(x, "Trident") || w(x, "MSIE");
var Ia = w(x, "Edge");
var Ja = Ia || y;
var Ka = w(x, "Gecko") && !(w(x.toLowerCase(), "webkit") && !w(x, "Edge")) && !(w(x, "Trident") || w(x, "MSIE")) && !w(x, "Edge");
var La = w(x.toLowerCase(), "webkit") && !w(x, "Edge");
function Ma() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Na;
a: {
  Oa2 = "", Pa2 = function() {
    var a = x;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ia)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (La)
      return /WebKit\/(\S+)/.exec(a);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Pa2 && (Oa2 = Pa2 ? Pa2[1] : "");
  if (y) {
    Qa2 = Ma();
    if (Qa2 != null && Qa2 > parseFloat(Oa2)) {
      Na = String(Qa2);
      break a;
    }
  }
  Na = Oa2;
}
var Oa2;
var Pa2;
var Qa2;
var Ga = {};
function Ra() {
  return Fa(function() {
    let a = 0;
    const b = ta(String(Na)).split("."), c = ta("9").split("."), d = Math.max(b.length, c.length);
    for (let h = 0; a == 0 && h < d; h++) {
      var e = b[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (e[0].length == 0 && f[0].length == 0)
          break;
        a = ua(e[1].length == 0 ? 0 : parseInt(e[1], 10), f[1].length == 0 ? 0 : parseInt(f[1], 10)) || ua(e[2].length == 0, f[2].length == 0) || ua(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (a == 0);
    }
    return 0 <= a;
  });
}
var Sa;
if (l.document && y) {
  Ta2 = Ma();
  Sa = Ta2 ? Ta2 : parseInt(Na, 10) || void 0;
} else
  Sa = void 0;
var Ta2;
var Ua = Sa;
var Va = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b), l.removeEventListener("test", aa, b);
  } catch (c) {
  }
  return a;
}();
function z(a, b) {
  this.type = a;
  this.g = this.target = b;
  this.defaultPrevented = false;
}
z.prototype.h = function() {
  this.defaultPrevented = true;
};
function A(a, b) {
  z.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b;
    if (b = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
    this.relatedTarget = b;
    d ? (this.clientX = d.clientX !== void 0 ? d.clientX : d.pageX, this.clientY = d.clientY !== void 0 ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Wa[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && A.Z.h.call(this);
  }
}
t(A, z);
var Wa = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.h = function() {
  A.Z.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var B = "closure_listenable_" + (1e6 * Math.random() | 0);
var Xa = 0;
function Ya(a, b, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d;
  this.ia = e;
  this.key = ++Xa;
  this.ca = this.fa = false;
}
function Za(a) {
  a.ca = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ia = null;
}
function $a(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
$a.prototype.add = function(a, b, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = ab(a, b, d, e);
  -1 < h ? (b = a[h], c || (b.fa = false)) : (b = new Ya(b, this.src, f, !!d, e), b.fa = c, a.push(b));
  return b;
};
function bb(a, b) {
  var c = b.type;
  if (c in a.g) {
    var d = a.g[c], e = ma(d, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Za(b), a.g[c].length == 0 && (delete a.g[c], a.h--));
  }
}
function ab(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ca && f.listener == b && f.capture == !!c && f.ia == d)
      return e;
  }
  return -1;
}
var cb = "closure_lm_" + (1e6 * Math.random() | 0);
var db = {};
function fb(a, b, c, d, e) {
  if (d && d.once)
    return gb(a, b, c, d, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      fb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.N(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, false, d, e);
}
function ib(a, b, c, d, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = jb(a);
  n || (a[cb] = n = new $a(a));
  c = n.add(b, c, d, h, f);
  if (c.proxy)
    return c;
  d = kb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Va || (e = h), e === void 0 && (e = false), a.addEventListener(b.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(lb(b.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function kb() {
  function a(c) {
    return b.call(a.src, a.listener, c);
  }
  var b = mb;
  return a;
}
function gb(a, b, c, d, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.O(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, true, d, e);
}
function nb(a, b, c, d, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      nb(a, b[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = hb(c), a && a[B]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = ab(f, c, d, e), -1 < c && (Za(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.g[b], a.h--)))) : a && (a = jb(a)) && (b = a.g[b.toString()], a = -1, b && (a = ab(b, c, d, e)), (c = -1 < a ? b[a] : null) && ob(c));
}
function ob(a) {
  if (typeof a !== "number" && a && !a.ca) {
    var b = a.src;
    if (b && b[B])
      bb(b.i, a);
    else {
      var c = a.type, d = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(lb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
      (c = jb(b)) ? (bb(c, a), c.h == 0 && (c.src = null, b[cb] = null)) : Za(a);
    }
  }
}
function lb(a) {
  return a in db ? db[a] : db[a] = "on" + a;
}
function mb(a, b) {
  if (a.ca)
    a = true;
  else {
    b = new A(b, this);
    var c = a.listener, d = a.ia || a.src;
    a.fa && ob(a);
    a = c.call(d, b);
  }
  return a;
}
function jb(a) {
  a = a[cb];
  return a instanceof $a ? a : null;
}
var pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function hb(a) {
  if (typeof a === "function")
    return a;
  a[pb] || (a[pb] = function(b) {
    return a.handleEvent(b);
  });
  return a[pb];
}
function C() {
  v.call(this);
  this.i = new $a(this);
  this.P = this;
  this.I = null;
}
t(C, v);
C.prototype[B] = true;
C.prototype.removeEventListener = function(a, b, c, d) {
  nb(this, a, b, c, d);
};
function D(a, b) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b.type || b;
  if (typeof b === "string")
    b = new z(b, a);
  else if (b instanceof z)
    b.target = b.target || a;
  else {
    var e = b;
    b = new z(d, a);
    Aa(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b.g = c[f];
      e = qb(h, d, true, b) && e;
    }
  h = b.g = a;
  e = qb(h, d, true, b) && e;
  e = qb(h, d, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b.g = c[f], e = qb(h, d, false, b) && e;
}
C.prototype.M = function() {
  C.Z.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Za(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
C.prototype.N = function(a, b, c, d) {
  return this.i.add(String(a), b, false, c, d);
};
C.prototype.O = function(a, b, c, d) {
  return this.i.add(String(a), b, true, c, d);
};
function qb(a, b, c, d) {
  b = a.i.g[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var h = b[f];
    if (h && !h.ca && h.capture == c) {
      var n = h.listener, u = h.ia || h.src;
      h.fa && bb(a.i, h);
      e = n.call(u, d) !== false && e;
    }
  }
  return e && !d.defaultPrevented;
}
var rb = l.JSON.stringify;
function sb() {
  var a = tb;
  let b = null;
  a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
  return b;
}
var ub = class {
  constructor() {
    this.h = this.g = null;
  }
  add(a, b) {
    const c = vb.get();
    c.set(a, b);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  }
};
var vb = new class {
  constructor(a, b) {
    this.i = a;
    this.j = b;
    this.h = 0;
    this.g = null;
  }
  get() {
    let a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  }
}(() => new wb(), (a) => a.reset());
var wb = class {
  constructor() {
    this.next = this.g = this.h = null;
  }
  set(a, b) {
    this.h = a;
    this.g = b;
    this.next = null;
  }
  reset() {
    this.next = this.g = this.h = null;
  }
};
function yb(a) {
  l.setTimeout(() => {
    throw a;
  }, 0);
}
function zb(a, b) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a, b);
}
var Ab;
function Bb() {
  var a = l.Promise.resolve(void 0);
  Ab = function() {
    a.then(Db);
  };
}
var Cb = false;
var tb = new ub();
function Db() {
  for (var a; a = sb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      yb(c);
    }
    var b = vb;
    b.j(a);
    100 > b.h && (b.h++, a.next = b.g, b.g = a);
  }
  Cb = false;
}
function Eb(a, b) {
  C.call(this);
  this.h = a || 1;
  this.g = b || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(Eb, C);
k = Eb.prototype;
k.da = false;
k.S = null;
k.kb = function() {
  if (this.da) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D(this, "tick"), this.da && (Fb(this), this.start()));
  }
};
k.start = function() {
  this.da = true;
  this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function Fb(a) {
  a.da = false;
  a.S && (a.g.clearTimeout(a.S), a.S = null);
}
k.M = function() {
  Eb.Z.M.call(this);
  Fb(this);
  delete this.g;
};
function Gb(a, b, c) {
  if (typeof a === "function")
    c && (a = q(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
}
function Hb(a) {
  a.g = Gb(() => {
    a.g = null;
    a.i && (a.i = false, Hb(a));
  }, a.j);
  const b = a.h;
  a.h = null;
  a.m.apply(null, b);
}
var Ib = class extends v {
  constructor(a, b) {
    super();
    this.m = a;
    this.j = b;
    this.h = null;
    this.i = false;
    this.g = null;
  }
  l(a) {
    this.h = arguments;
    this.g ? this.i = true : Hb(this);
  }
  M() {
    super.M();
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  }
};
function E(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(E, v);
var Jb = [];
function Kb(a, b, c, d) {
  Array.isArray(c) || (c && (Jb[0] = c.toString()), c = Jb);
  for (var e = 0; e < c.length; e++) {
    var f = fb(b, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Lb(a) {
  xa(a.g, function(b, c) {
    this.g.hasOwnProperty(c) && ob(b);
  }, a);
  a.g = {};
}
E.prototype.M = function() {
  E.Z.M.call(this);
  Lb(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Mb() {
  this.g = true;
}
Mb.prototype.Aa = function() {
  this.g = false;
};
function Nb(a, b, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var G2 = r.split("_");
            h = 2 <= G2.length && G2[1] == "type" ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
  });
}
function Ob(a, b, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
  });
}
function F(a, b, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Pb(a, c) + (d ? " " + d : "");
  });
}
function Qb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
Mb.prototype.info = function() {
};
function Pb(a, b) {
  if (!a.g)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return rb(c);
  } catch (n) {
    return b;
  }
}
var H = {};
var Rb = null;
function Sb() {
  return Rb = Rb || new C();
}
H.Ma = "serverreachability";
function Tb(a) {
  z.call(this, H.Ma, a);
}
t(Tb, z);
function I(a) {
  const b = Sb();
  D(b, new Tb(b, a));
}
H.STAT_EVENT = "statevent";
function Ub(a, b) {
  z.call(this, H.STAT_EVENT, a);
  this.stat = b;
}
t(Ub, z);
function J(a) {
  const b = Sb();
  D(b, new Ub(b, a));
}
H.Na = "timingevent";
function Vb(a, b) {
  z.call(this, H.Na, a);
  this.size = b;
}
t(Vb, z);
function K(a, b) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b);
}
var Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
var Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Yb() {
}
Yb.prototype.h = null;
function Zb(a) {
  return a.h || (a.h = a.i());
}
function $b() {
}
var L = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
function ac() {
  z.call(this, "d");
}
t(ac, z);
function bc() {
  z.call(this, "c");
}
t(bc, z);
var cc;
function dc() {
}
t(dc, Yb);
dc.prototype.g = function() {
  return new XMLHttpRequest();
};
dc.prototype.i = function() {
  return {};
};
cc = new dc();
function M(a, b, c, d) {
  this.l = a;
  this.j = b;
  this.m = c;
  this.X = d || 1;
  this.V = new E(this);
  this.P = ec;
  a = Ja ? 125 : void 0;
  this.W = new Eb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc();
}
function fc() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var ec = 45e3;
var gc = {};
var hc = {};
k = M.prototype;
k.setTimeout = function(a) {
  this.P = a;
};
function ic(a, b, c) {
  a.K = 1;
  a.v = jc(N(b));
  a.s = c;
  a.U = true;
  kc(a, null);
}
function kc(a, b) {
  a.F = Date.now();
  lc(a);
  a.A = N(a.v);
  var c = a.A, d = a.X;
  Array.isArray(d) || (d = [String(d)]);
  mc(c.h, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new fc();
  a.g = nc(a.l, c ? b : null, !a.s);
  0 < a.O && (a.L = new Ib(q(a.Ia, a, a.g), a.O));
  Kb(a.V, a.g, "readystatechange", a.gb);
  b = a.H ? ya(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(a.A, a.u, a.s, b)) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
  I(1);
  Nb(a.j, a.u, a.A, a.m, a.X, a.s);
}
k.gb = function(a) {
  a = a.target;
  const b = this.L;
  b && O(a) == 3 ? b.l() : this.Ia(a);
};
k.Ia = function(a) {
  try {
    if (a == this.g)
      a: {
        const r = O(this.g);
        var b = this.g.Da();
        const G2 = this.g.ba();
        if (!(3 > r) && (r != 3 || Ja || this.g && (this.h.h || this.g.ga() || oc(this.g)))) {
          this.I || r != 4 || b == 7 || (b == 8 || 0 >= G2 ? I(3) : I(2));
          pc(this);
          var c = this.g.ba();
          this.N = c;
          b:
            if (qc(this)) {
              var d = oc(this.g);
              a = "";
              var e = d.length, f = O(this.g) == 4;
              if (!this.h.i) {
                if (typeof TextDecoder === "undefined") {
                  P(this);
                  rc(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b = 0; b < e; b++)
                this.h.h = true, a += this.h.i.decode(d[b], { stream: f && b == e - 1 });
              d.splice(0, e);
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.ga();
          this.i = c == 200;
          Ob(this.j, this.u, this.A, this.m, this.X, r, c);
          if (this.i) {
            if (this.$ && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                F(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc(this, c);
              else {
                this.i = false;
                this.o = 3;
                J(12);
                P(this);
                rc(this);
                break a;
              }
            }
            this.U ? (tc(this, r, h), Ja && this.i && r == 3 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F(this.j, this.m, h, null), sc(this, h));
            r == 4 && P(this);
            this.i && !this.I && (r == 4 ? uc(this.l, this) : (this.i = false, lc(this)));
          } else
            c == 400 && 0 < h.indexOf("Unknown SID") ? (this.o = 3, J(12)) : (this.o = 0, J(13)), P(this), rc(this);
        }
      }
  } catch (r) {
  } finally {
  }
};
function qc(a) {
  return a.g ? a.u == "GET" && a.K != 2 && a.l.Ba : false;
}
function tc(a, b, c) {
  let d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = vc(a, c), e == hc) {
      b == 4 && (a.o = 4, J(14), d = false);
      F(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == gc) {
      a.o = 4;
      J(15);
      F(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      F(a.j, a.m, e, null), sc(a, e);
  qc(a) && e != hc && e != gc && (a.h.g = "", a.C = 0);
  b != 4 || c.length != 0 || a.h.h || (a.o = 1, J(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.aa && (a.aa = true, b = a.l, b.g == a && b.$ && !b.L && (b.h.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc(b), b.L = true, J(11))) : (F(a.j, a.m, c, "[Invalid Chunked Response]"), P(a), rc(a));
}
k.fb = function() {
  if (this.g) {
    var a = O(this.g), b = this.g.ga();
    this.C < b.length && (pc(this), tc(this, a, b), this.i && a != 4 && lc(this));
  }
};
function vc(a, b) {
  var c = a.C, d = b.indexOf("\n", c);
  if (d == -1)
    return hc;
  c = Number(b.substring(c, d));
  if (isNaN(c))
    return gc;
  d += 1;
  if (d + c > b.length)
    return hc;
  b = b.substr(d, c);
  a.C = d + c;
  return b;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function lc(a) {
  a.Y = Date.now() + a.P;
  xc(a, a.P);
}
function xc(a, b) {
  if (a.B != null)
    throw Error("WatchDog timer not null");
  a.B = K(q(a.eb, a), b);
}
function pc(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.eb = function() {
  this.B = null;
  const a = Date.now();
  0 <= a - this.Y ? (Qb(this.j, this.A), this.K != 2 && (I(3), J(17)), P(this), this.o = 2, rc(this)) : xc(this, this.Y - a);
};
function rc(a) {
  a.l.G == 0 || a.I || uc(a.l, a);
}
function P(a) {
  pc(a);
  var b = a.L;
  b && typeof b.na == "function" && b.na();
  a.L = null;
  Fb(a.W);
  Lb(a.V);
  a.g && (b = a.g, a.g = null, b.abort(), b.na());
}
function sc(a, b) {
  try {
    var c = a.l;
    if (c.G != 0 && (c.g == a || yc(c.i, a))) {
      if (c.I = a.N, !a.J && yc(c.i, a) && c.G == 3) {
        try {
          var d = c.Ca.g.parse(b);
        } catch (m) {
          d = null;
        }
        if (Array.isArray(d) && d.length == 3) {
          var e = d;
          if (e[0] == 0)
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    zc(c), Ac(c);
                  else
                    break a;
                Bc(c);
                J(18);
              }
            }
          else
            c.ta = e[1], 0 < c.ta - c.U && 37500 > e[2] && c.N && c.A == 0 && !c.v && (c.v = K(q(c.ab, c), 6e3));
          if (1 >= Cc(c.i) && c.ka) {
            try {
              c.ka();
            } catch (m) {
            }
            c.ka = void 0;
          }
        } else
          Q(c, 11);
      } else if ((a.J || c.g == a) && zc(c), !sa(b))
        for (e = c.Ca.g.parse(b), b = 0; b < e.length; b++) {
          let m = e[b];
          c.U = m[0];
          m = m[1];
          if (c.G == 2)
            if (m[0] == "c") {
              c.J = m[1];
              c.la = m[2];
              const r = m[3];
              r != null && (c.ma = r, c.h.info("VER=" + c.ma));
              const G2 = m[4];
              G2 != null && (c.za = G2, c.h.info("SVER=" + c.za));
              const Da2 = m[5];
              Da2 != null && typeof Da2 === "number" && 0 < Da2 && (d = 1.5 * Da2, c.K = d, c.h.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              const ca2 = a.g;
              if (ca2) {
                const Ea2 = ca2.g ? ca2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea2) {
                  var f = d.i;
                  !f.g && (w(Ea2, "spdy") || w(Ea2, "quic") || w(Ea2, "h2")) && (f.j = f.l, f.g = new Set(), f.h && (Dc(f, f.h), f.h = null));
                }
                if (d.D) {
                  const xb = ca2.g ? ca2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d.sa = xb, R(d.F, d.D, xb));
                }
              }
              c.G = 3;
              c.j && c.j.xa();
              c.$ && (c.O = Date.now() - a.F, c.h.info("Handshake RTT: " + c.O + "ms"));
              d = c;
              var h = a;
              d.oa = Ec(d, d.H ? d.la : null, d.W);
              if (h.J) {
                Fc(d.i, h);
                var n = h, u = d.K;
                u && n.setTimeout(u);
                n.B && (pc(n), lc(n));
                d.g = h;
              } else
                Gc(d);
              0 < c.l.length && Hc(c);
            } else
              m[0] != "stop" && m[0] != "close" || Q(c, 7);
          else
            c.G == 3 && (m[0] == "stop" || m[0] == "close" ? m[0] == "stop" ? Q(c, 7) : Ic(c) : m[0] != "noop" && c.j && c.j.wa(m), c.A = 0);
        }
    }
    I(4);
  } catch (m) {
  }
}
function Jc(a) {
  if (a.R && typeof a.R == "function")
    return a.R();
  if (typeof a === "string")
    return a.split("");
  if (ba(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++)
      b.push(a[d]);
    return b;
  }
  b = [];
  c = 0;
  for (d in a)
    b[c++] = a[d];
  return b;
}
function Kc(a, b) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b, void 0);
  else if (ba(a) || typeof a === "string")
    na(a, b, void 0);
  else {
    if (a.T && typeof a.T == "function")
      var c = a.T();
    else if (a.R && typeof a.R == "function")
      c = void 0;
    else if (ba(a) || typeof a === "string") {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Jc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d[f], c && c[f], a);
  }
}
function S(a, b) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.T(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
k = S.prototype;
k.R = function() {
  Lc(this);
  for (var a = [], b = 0; b < this.g.length; b++)
    a.push(this.h[this.g[b]]);
  return a;
};
k.T = function() {
  Lc(this);
  return this.g.concat();
};
function Lc(a) {
  if (a.i != a.g.length) {
    for (var b = 0, c = 0; b < a.g.length; ) {
      var d = a.g[b];
      T(a.h, d) && (a.g[c++] = d);
      b++;
    }
    a.g.length = c;
  }
  if (a.i != a.g.length) {
    var e = {};
    for (c = b = 0; b < a.g.length; )
      d = a.g[b], T(e, d) || (a.g[c++] = d, e[d] = 1), b++;
    a.g.length = c;
  }
}
k.get = function(a, b) {
  return T(this.h, a) ? this.h[a] : b;
};
k.set = function(a, b) {
  T(this.h, a) || (this.i++, this.g.push(a));
  this.h[a] = b;
};
k.forEach = function(a, b) {
  for (var c = this.T(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b, f, e, this);
  }
};
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
var Mc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Nc(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a instanceof U) {
    this.g = b !== void 0 ? b : a.g;
    Oc(this, a.j);
    this.s = a.s;
    Pc(this, a.i);
    Qc(this, a.m);
    this.l = a.l;
    b = a.h;
    var c = new Rc();
    c.i = b.i;
    b.g && (c.g = new S(b.g), c.h = b.h);
    Sc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Mc)) ? (this.g = !!b, Oc(this, c[1] || "", true), this.s = Tc(c[2] || ""), Pc(this, c[3] || "", true), Qc(this, c[4]), this.l = Tc(c[5] || "", true), Sc(this, c[6] || "", true), this.o = Tc(c[7] || "")) : (this.g = !!b, this.h = new Rc(null, this.g));
}
U.prototype.toString = function() {
  var a = [], b = this.j;
  b && a.push(Uc(b, Vc, true), ":");
  var c = this.i;
  if (c || b == "file")
    a.push("//"), (b = this.s) && a.push(Uc(b, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, c != null && a.push(":", String(c));
  if (c = this.l)
    this.i && c.charAt(0) != "/" && a.push("/"), a.push(Uc(c, c.charAt(0) == "/" ? Wc : Xc, true));
  (c = this.h.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Uc(c, Yc));
  return a.join("");
};
function N(a) {
  return new U(a);
}
function Oc(a, b, c) {
  a.j = c ? Tc(b, true) : b;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Pc(a, b, c) {
  a.i = c ? Tc(b, true) : b;
}
function Qc(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.m = b;
  } else
    a.m = null;
}
function Sc(a, b, c) {
  b instanceof Rc ? (a.h = b, Zc(a.h, a.g)) : (c || (b = Uc(b, $c)), a.h = new Rc(b, a.g));
}
function R(a, b, c) {
  a.h.set(b, c);
}
function jc(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof U ? N(a) : new U(a, void 0);
}
function bd(a, b, c, d) {
  var e = new U(null, void 0);
  a && Oc(e, a);
  b && Pc(e, b);
  c && Qc(e, c);
  d && (e.l = d);
  return e;
}
function Tc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Vc = /[#\/\?@]/g;
var Xc = /[#\?:]/g;
var Wc = /[#\?]/g;
var $c = /[#\?@]/g;
var Yc = /#/g;
function Rc(a, b) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b;
}
function V(a) {
  a.g || (a.g = new S(), a.h = 0, a.i && Nc(a.i, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
k = Rc.prototype;
k.add = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b);
  this.h += 1;
  return this;
};
function dd(a, b) {
  V(a);
  b = W(a, b);
  T(a.g.h, b) && (a.i = null, a.h -= a.g.get(b).length, a = a.g, T(a.h, b) && (delete a.h[b], a.i--, a.g.length > 2 * a.i && Lc(a)));
}
function ed(a, b) {
  V(a);
  b = W(a, b);
  return T(a.g.h, b);
}
k.forEach = function(a, b) {
  V(this);
  this.g.forEach(function(c, d) {
    na(c, function(e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
k.T = function() {
  V(this);
  for (var a = this.g.R(), b = this.g.T(), c = [], d = 0; d < b.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b[d]);
  return c;
};
k.R = function(a) {
  V(this);
  var b = [];
  if (typeof a === "string")
    ed(this, a) && (b = qa(b, this.g.get(W(this, a))));
  else {
    a = this.g.R();
    for (var c = 0; c < a.length; c++)
      b = qa(b, a[c]);
  }
  return b;
};
k.set = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  ed(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b]);
  this.h += 1;
  return this;
};
k.get = function(a, b) {
  if (!a)
    return b;
  a = this.R(a);
  return 0 < a.length ? String(a[0]) : b;
};
function mc(a, b, c) {
  dd(a, b);
  0 < c.length && (a.i = null, a.g.set(W(a, b), ra(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  for (var a = [], b = this.g.T(), c = 0; c < b.length; c++) {
    var d = b[c], e = encodeURIComponent(String(d));
    d = this.R(d);
    for (var f = 0; f < d.length; f++) {
      var h = e;
      d[f] !== "" && (h += "=" + encodeURIComponent(String(d[f])));
      a.push(h);
    }
  }
  return this.i = a.join("&");
};
function W(a, b) {
  b = String(b);
  a.j && (b = b.toLowerCase());
  return b;
}
function Zc(a, b) {
  b && !a.j && (V(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (dd(this, d), mc(this, e, c));
  }, a));
  a.j = b;
}
var fd = class {
  constructor(a, b) {
    this.h = a;
    this.g = b;
  }
};
function gd(a) {
  this.l = a || hd;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = new Set());
  this.h = null;
  this.i = [];
}
var hd = 10;
function id(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function Cc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function yc(a, b) {
  return a.h ? a.h == b : a.g ? a.g.has(b) : false;
}
function Dc(a, b) {
  a.g ? a.g.add(b) : a.h = b;
}
function Fc(a, b) {
  a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
}
gd.prototype.cancel = function() {
  this.i = jd(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && this.g.size !== 0) {
    for (const a of this.g.values())
      a.cancel();
    this.g.clear();
  }
};
function jd(a) {
  if (a.h != null)
    return a.i.concat(a.h.D);
  if (a.g != null && a.g.size !== 0) {
    let b = a.i;
    for (const c of a.g.values())
      b = b.concat(c.D);
    return b;
  }
  return ra(a.i);
}
function kd() {
}
kd.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
kd.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ld() {
  this.g = new kd();
}
function md(a, b, c) {
  const d = c || "";
  try {
    Kc(a, function(e, f) {
      let h = e;
      p(e) && (h = rb(e));
      b.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b) {
  const c = new Mb();
  if (l.Image) {
    const d = new Image();
    d.onload = ja(od, c, d, "TestLoadImage: loaded", true, b);
    d.onerror = ja(od, c, d, "TestLoadImage: error", false, b);
    d.onabort = ja(od, c, d, "TestLoadImage: abort", false, b);
    d.ontimeout = ja(od, c, d, "TestLoadImage: timeout", false, b);
    l.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a;
  } else
    b(false);
}
function od(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {
  }
}
function pd(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
t(pd, Yb);
pd.prototype.g = function() {
  return new qd(this.l, this.j);
};
pd.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function qd(a, b) {
  C.call(this);
  this.D = a;
  this.u = b;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(qd, C);
var rd = 0;
k = qd.prototype;
k.open = function(a, b) {
  if (this.readyState != rd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b;
  this.readyState = 1;
  sd(this);
};
k.send = function(a) {
  if (this.readyState != 1)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  const b = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b.body = a);
  (this.D || l).fetch(new Request(this.B, b)).then(this.Va.bind(this), this.ha.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.");
  1 <= this.readyState && this.g && this.readyState != 4 && (this.g = false, td(this));
  this.readyState = rd;
};
k.Va = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
    if (this.responseType === "arraybuffer")
      a.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
    else if (typeof l.ReadableStream !== "undefined" && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      ud(this);
    } else
      a.text().then(this.Ua.bind(this), this.ha.bind(this));
};
function ud(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ha.bind(a));
}
k.Sa = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b = a.value ? a.value : new Uint8Array(0);
      if (b = this.A.decode(b, { stream: !a.done }))
        this.response = this.responseText += b;
    }
    a.done ? td(this) : sd(this);
    this.readyState == 3 && ud(this);
  }
};
k.Ua = function(a) {
  this.g && (this.response = this.responseText = a, td(this));
};
k.Ta = function(a) {
  this.g && (this.response = a, td(this));
};
k.ha = function() {
  this.g && td(this);
};
function td(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  sd(a);
}
k.setRequestHeader = function(a, b) {
  this.v.append(a, b);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  const a = [], b = this.h.entries();
  for (var c = b.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
  return a.join("\r\n");
};
function sd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
  return this.m === "include";
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var vd = l.JSON.parse;
function X(a) {
  C.call(this);
  this.headers = new S();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
t(X, C);
var wd = "";
var xd = /^https?$/i;
var yd = ["POST", "PUT"];
k = X.prototype;
k.ea = function(a, b, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b = b ? b.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : cc.g();
  this.C = this.u ? Zb(this.u) : Zb(cc);
  this.g.onreadystatechange = q(this.Fa, this);
  try {
    this.F = true, this.g.open(b, String(a), true), this.F = false;
  } catch (f) {
    zd(this, f);
    return;
  }
  a = c || "";
  const e = new S(this.headers);
  d && Kc(d, function(f, h) {
    e.set(h, f);
  });
  d = oa(e.T());
  c = l.FormData && a instanceof l.FormData;
  !(0 <= ma(yd, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, h) {
    this.g.setRequestHeader(h, f);
  }, this);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    zd(this, f);
  }
};
function Bd(a) {
  return y && Ra() && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa(a) {
  return a.toLowerCase() == "content-type";
}
k.pa = function() {
  typeof goog != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D(this, "timeout"), this.abort(8));
};
function zd(a, b) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b;
  a.m = 5;
  Cd(a);
  Dd(a);
}
function Cd(a) {
  a.D || (a.D = true, D(a, "complete"), D(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, D(this, "complete"), D(this, "abort"), Dd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
  X.Z.M.call(this);
};
k.Fa = function() {
  this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
};
k.cb = function() {
  Ed(this);
};
function Ed(a) {
  if (a.h && typeof goog != "undefined" && (!a.C[1] || O(a) != 4 || a.ba() != 2)) {
    if (a.v && O(a) == 4)
      Gb(a.Fa, 0, a);
    else if (D(a, "readystatechange"), O(a) == 4) {
      a.h = false;
      try {
        const n = a.ba();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
        var c;
        if (!(c = b)) {
          var d;
          if (d = n === 0) {
            var e = String(a.H).match(Mc)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !xd.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          D(a, "complete"), D(a, "success");
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.ba() + "]";
          Cd(a);
        }
      } finally {
        Dd(a);
      }
    }
  }
}
function Dd(a, b) {
  if (a.g) {
    Ad(a);
    const c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b || D(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function Ad(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.ba = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.ga = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Qa = function(a) {
  if (this.g) {
    var b = this.g.responseText;
    a && b.indexOf(a) == 0 && (b = b.substring(a.length));
    return vd(b);
  }
};
function oc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case wd:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b) {
    return null;
  }
}
k.Da = function() {
  return this.m;
};
k.La = function() {
  return typeof this.j === "string" ? this.j : String(this.j);
};
function Fd(a) {
  let b = "";
  xa(a, function(c, d) {
    b += d;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Gd(a, b, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = Fd(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R(a, b, c));
}
function Hd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Id(a) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a);
  this.$a = Hd("retryDelaySeedMs", 1e4, a);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.qa = a && a.xmlHttpFactory || void 0;
  this.Ba = a && a.Yb || false;
  this.K = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a && a.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a && a.fastHandshake || false;
  this.Ra = a && a.Wb || false;
  a && a.Aa && this.h.Aa();
  a && a.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a && a.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a || a.Xb !== false;
}
k = Id.prototype;
k.ma = 8;
k.G = 1;
function Ic(a) {
  Jd(a);
  if (a.G == 3) {
    var b = a.V++, c = N(a.F);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Kd(a, c);
    b = new M(a, a.h, b, void 0);
    b.K = 2;
    b.v = jc(N(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b.v.toString(), ""));
    !c && l.Image && (new Image().src = b.v, c = true);
    c || (b.g = nc(b.l, null), b.g.ea(b.v));
    b.F = Date.now();
    lc(b);
  }
  Ld(a);
}
k.hb = function(a) {
  try {
    this.h.info("Origin Trials invoked: " + a);
  } catch (b) {
  }
};
function Ac(a) {
  a.g && (wc(a), a.g.cancel(), a.g = null);
}
function Jd(a) {
  Ac(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  zc(a);
  a.i.cancel();
  a.m && (typeof a.m === "number" && l.clearTimeout(a.m), a.m = null);
}
function Md(a, b) {
  a.l.push(new fd(a.Za++, b));
  a.G == 3 && Hc(a);
}
function Hc(a) {
  id(a.i) || a.m || (a.m = true, zb(a.Ha, a), a.C = 0);
}
function Nd(a, b) {
  if (Cc(a.i) >= a.i.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.l = b.D.concat(a.l), true;
  if (a.G == 1 || a.G == 2 || a.C >= (a.Xa ? 0 : a.Ya))
    return false;
  a.m = K(q(a.Ha, a, b), Od(a, a.C));
  a.C++;
  return true;
}
k.Ha = function(a) {
  if (this.m)
    if (this.m = null, this.G == 1) {
      if (!a) {
        this.V = Math.floor(1e5 * Math.random());
        a = this.V++;
        const e = new M(this, this.h, a, void 0);
        let f = this.s;
        this.P && (f ? (f = ya(f), Aa(f, this.P)) : f = this.P);
        this.o === null && (e.H = f);
        if (this.ja)
          a: {
            var b = 0;
            for (var c = 0; c < this.l.length; c++) {
              b: {
                var d = this.l[c];
                if ("__data__" in d.g && (d = d.g.__data__, typeof d === "string")) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (d === void 0)
                break;
              b += d;
              if (4096 < b) {
                b = c;
                break a;
              }
              if (b === 4096 || c === this.l.length - 1) {
                b = c + 1;
                break a;
              }
            }
            b = 1e3;
          }
        else
          b = 1e3;
        b = Pd(this, e, b);
        c = N(this.F);
        R(c, "RID", a);
        R(c, "CVER", 22);
        this.D && R(c, "X-HTTP-Session-Id", this.D);
        Kd(this, c);
        this.o && f && Gd(c, this.o, f);
        Dc(this.i, e);
        this.Ra && R(c, "TYPE", "init");
        this.ja ? (R(c, "$req", b), R(c, "SID", "null"), e.$ = true, ic(e, c, null)) : ic(e, c, b);
        this.G = 2;
      }
    } else
      this.G == 3 && (a ? Qd(this, a) : this.l.length == 0 || id(this.i) || Qd(this));
};
function Qd(a, b) {
  var c;
  b ? c = b.m : c = a.V++;
  const d = N(a.F);
  R(d, "SID", a.J);
  R(d, "RID", c);
  R(d, "AID", a.U);
  Kd(a, d);
  a.o && a.s && Gd(d, a.o, a.s);
  c = new M(a, a.h, c, a.C + 1);
  a.o === null && (c.H = a.s);
  b && (a.l = b.D.concat(a.l));
  b = Pd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ra) + Math.round(0.5 * a.ra * Math.random()));
  Dc(a.i, c);
  ic(c, d, b);
}
function Kd(a, b) {
  a.j && Kc({}, function(c, d) {
    R(b, d, c);
  });
}
function Pd(a, b, c) {
  c = Math.min(a.l.length, c);
  var d = a.j ? q(a.j.Oa, a.j, a) : null;
  a: {
    var e = a.l;
    let f = -1;
    for (; ; ) {
      const h = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      let n = true;
      for (let u = 0; u < c; u++) {
        let m = e[u].h;
        const r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            md(r, h, "req" + m + "_");
          } catch (G2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.l.splice(0, c);
  b.D = a;
  return d;
}
function Gc(a) {
  a.g || a.u || (a.Y = 1, zb(a.Ga, a), a.A = 0);
}
function Bc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Y++;
  a.u = K(q(a.Ga, a), Od(a, a.A));
  a.A++;
  return true;
}
k.Ga = function() {
  this.u = null;
  Rd(this);
  if (this.$ && !(this.L || this.g == null || 0 >= this.O)) {
    var a = 2 * this.O;
    this.h.info("BP detection timer enabled: " + a);
    this.B = K(q(this.bb, this), a);
  }
};
k.bb = function() {
  this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J(10), Ac(this), Rd(this));
};
function wc(a) {
  a.B != null && (l.clearTimeout(a.B), a.B = null);
}
function Rd(a) {
  a.g = new M(a, a.h, "rpc", a.Y);
  a.o === null && (a.g.H = a.s);
  a.g.O = 0;
  var b = N(a.oa);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.N ? "0" : "1");
  R(b, "AID", a.U);
  Kd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.o && a.s && Gd(b, a.o, a.s);
  a.K && a.g.setTimeout(a.K);
  var c = a.g;
  a = a.la;
  c.K = 1;
  c.v = jc(N(b));
  c.s = null;
  c.U = true;
  kc(c, a);
}
k.ab = function() {
  this.v != null && (this.v = null, Ac(this), Bc(this), J(19));
};
function zc(a) {
  a.v != null && (l.clearTimeout(a.v), a.v = null);
}
function uc(a, b) {
  var c = null;
  if (a.g == b) {
    zc(a);
    wc(a);
    a.g = null;
    var d = 2;
  } else if (yc(a.i, b))
    c = b.D, Fc(a.i, b), d = 1;
  else
    return;
  a.I = b.N;
  if (a.G != 0) {
    if (b.i)
      if (d == 1) {
        c = b.s ? b.s.length : 0;
        b = Date.now() - b.F;
        var e = a.C;
        d = Sb();
        D(d, new Vb(d, c, b, e));
        Hc(a);
      } else
        Gc(a);
    else if (e = b.o, e == 3 || e == 0 && 0 < a.I || !(d == 1 && Nd(a, b) || d == 2 && Bc(a)))
      switch (c && 0 < c.length && (b = a.i, b.i = b.i.concat(c)), e) {
        case 1:
          Q(a, 5);
          break;
        case 4:
          Q(a, 10);
          break;
        case 3:
          Q(a, 6);
          break;
        default:
          Q(a, 2);
      }
  }
}
function Od(a, b) {
  let c = a.Pa + Math.floor(Math.random() * a.$a);
  a.j || (c *= 2);
  return c * b;
}
function Q(a, b) {
  a.h.info("Error code " + b);
  if (b == 2) {
    var c = null;
    a.j && (c = null);
    var d = q(a.jb, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Oc(c, "https"), jc(c));
    nd(c.toString(), d);
  } else
    J(2);
  a.G = 0;
  a.j && a.j.va(b);
  Ld(a);
  Jd(a);
}
k.jb = function(a) {
  a ? (this.h.info("Successfully pinged google.com"), J(2)) : (this.h.info("Failed to ping google.com"), J(1));
};
function Ld(a) {
  a.G = 0;
  a.I = -1;
  if (a.j) {
    if (jd(a.i).length != 0 || a.l.length != 0)
      a.i.i.length = 0, ra(a.l), a.l.length = 0;
    a.j.ua();
  }
}
function Ec(a, b, c) {
  let d = ad(c);
  if (d.i != "")
    b && Pc(d, b + "." + d.i), Qc(d, d.m);
  else {
    const e = l.location;
    d = bd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.aa && xa(a.aa, function(e, f) {
    R(d, f, e);
  });
  b = a.D;
  c = a.sa;
  b && c && R(d, b, c);
  R(d, "VER", a.ma);
  Kd(a, d);
  return d;
}
function nc(a, b, c) {
  if (b && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = c && a.Ba && !a.qa ? new X(new pd({ ib: true })) : new X(a.qa);
  b.L = a.H;
  return b;
}
function Sd() {
}
k = Sd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Oa = function() {
};
function Td() {
  if (y && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
Td.prototype.g = function(a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  C.call(this);
  this.g = new Id(b);
  this.l = a;
  this.h = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.ya && (a ? a["X-WebChannel-Client-Profile"] = b.ya : a = { "X-WebChannel-Client-Profile": b.ya });
  this.g.P = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.g.o = a);
  this.A = b && b.supportsCrossDomainXhr || false;
  this.v = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.g.D = b, a = this.h, a !== null && b in a && (a = this.h, b in a && delete a[b]));
  this.j = new Z(this);
}
t(Y, C);
Y.prototype.m = function() {
  this.g.j = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b = this.l, c = this.h || void 0;
  a.Wa && (a.h.info("Origin Trials enabled."), zb(q(a.hb, a, b)));
  J(0);
  a.W = b;
  a.aa = c || {};
  a.N = a.X;
  a.F = Ec(a, null, a.W);
  Hc(a);
};
Y.prototype.close = function() {
  Ic(this.g);
};
Y.prototype.u = function(a) {
  if (typeof a === "string") {
    var b = {};
    b.__data__ = a;
    Md(this.g, b);
  } else
    this.v ? (b = {}, b.__data__ = rb(a), Md(this.g, b)) : Md(this.g, a);
};
Y.prototype.M = function() {
  this.g.j = null;
  delete this.j;
  Ic(this.g);
  delete this.g;
  Y.Z.M.call(this);
};
function Ud(a) {
  ac.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (const c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b = b !== null && a in b ? b[a] : void 0;
    this.data = b;
  } else
    this.data = a;
}
t(Ud, ac);
function Vd() {
  bc.call(this);
  this.status = 1;
}
t(Vd, bc);
function Z(a) {
  this.g = a;
}
t(Z, Sd);
Z.prototype.xa = function() {
  D(this.g, "a");
};
Z.prototype.wa = function(a) {
  D(this.g, new Ud(a));
};
Z.prototype.va = function(a) {
  D(this.g, new Vd(a));
};
Z.prototype.ua = function() {
  D(this.g, "b");
};
Td.prototype.createWebChannel = Td.prototype.g;
Y.prototype.send = Y.prototype.u;
Y.prototype.open = Y.prototype.m;
Y.prototype.close = Y.prototype.close;
Wb.NO_ERROR = 0;
Wb.TIMEOUT = 8;
Wb.HTTP_ERROR = 6;
Xb.COMPLETE = "complete";
$b.EventType = L;
L.OPEN = "a";
L.CLOSE = "b";
L.ERROR = "c";
L.MESSAGE = "d";
C.prototype.listen = C.prototype.N;
X.prototype.listenOnce = X.prototype.O;
X.prototype.getLastError = X.prototype.La;
X.prototype.getLastErrorCode = X.prototype.Da;
X.prototype.getStatus = X.prototype.ba;
X.prototype.getResponseJson = X.prototype.Qa;
X.prototype.getResponseText = X.prototype.ga;
X.prototype.send = X.prototype.ea;
var createWebChannelTransport = esm.createWebChannelTransport = function() {
  return new Td();
};
var getStatEventTarget = esm.getStatEventTarget = function() {
  return Sb();
};
var ErrorCode = esm.ErrorCode = Wb;
var EventType = esm.EventType = Xb;
var Event = esm.Event = H;
var Stat = esm.Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = esm.FetchXmlHttpFactory = pd;
var WebChannel = esm.WebChannel = $b;
var XhrIo = esm.XhrIo = X;

// node_modules/@firebase/firestore/dist/index.esm2017.js
var S2 = "@firebase/firestore";
var D2 = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
D2.UNAUTHENTICATED = new D2(null), D2.GOOGLE_CREDENTIALS = new D2("google-credentials-uid"), D2.FIRST_PARTY = new D2("first-party-uid"), D2.MOCK_USER = new D2("mock-user");
var C2 = "9.6.1";
var N2 = new Logger("@firebase/firestore");
function k2() {
  return N2.logLevel;
}
function x2(t2) {
  N2.setLogLevel(t2);
}
function $(t2, ...e) {
  if (N2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(M2);
    N2.debug(`Firestore (${C2}): ${t2}`, ...n);
  }
}
function F2(t2, ...e) {
  if (N2.logLevel <= LogLevel.ERROR) {
    const n = e.map(M2);
    N2.error(`Firestore (${C2}): ${t2}`, ...n);
  }
}
function O2(t2, ...e) {
  if (N2.logLevel <= LogLevel.WARN) {
    const n = e.map(M2);
    N2.warn(`Firestore (${C2}): ${t2}`, ...n);
  }
}
function M2(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function L2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${C2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw F2(e), new Error(e);
}
function B2(t2, e) {
  t2 || L2();
}
function U2(t2, e) {
  t2 || L2();
}
function q2(t2, e) {
  return t2;
}
var K2 = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var j = class extends Error {
  constructor(t2, e) {
    super(e), this.code = t2, this.message = e, this.name = "FirebaseError", this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var Q2 = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var W2 = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.headers = new Map(), this.headers.set("Authorization", `Bearer ${t2}`);
  }
};
var G = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(D2.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var z2 = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var H2 = class {
  constructor(t2) {
    this.t = t2, this.currentUser = D2.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e) {
    let n = this.i;
    const s = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
    let i = new Q2();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new Q2(), t2.enqueueRetryable(() => s(this.currentUser));
    };
    const r = () => {
      const e2 = i;
      t2.enqueueRetryable(async () => {
        await e2.promise, await s(this.currentUser);
      });
    }, o = (t3) => {
      $("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r();
    };
    this.t.onInit((t3) => o(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? o(t3) : ($("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new Q2());
      }
    }, 0), r();
  }
  getToken() {
    const t2 = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? ($("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (B2(typeof e2.accessToken == "string"), new W2(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return B2(t2 === null || typeof t2 == "string"), new D2(t2);
  }
};
var J2 = class {
  constructor(t2, e, n) {
    this.type = "FirstParty", this.user = D2.FIRST_PARTY, this.headers = new Map(), this.headers.set("X-Goog-AuthUser", e);
    const s = t2.auth.getAuthHeaderValueForFirstParty([]);
    s && this.headers.set("Authorization", s), n && this.headers.set("X-Goog-Iam-Authorization-Token", n);
  }
};
var Y2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n;
  }
  getToken() {
    return Promise.resolve(new J2(this.h, this.l, this.m));
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(D2.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var X2 = class {
  constructor(t2) {
    this.value = t2, this.type = "AppCheck", this.headers = new Map(), t2 && t2.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
};
var Z2 = class {
  constructor(t2) {
    this.g = t2, this.forceRefresh = false, this.appCheck = null;
  }
  start(t2, e) {
    this.o = (n2) => {
      t2.enqueueRetryable(() => ((t3) => (t3.error != null && $("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t3.error.message}`), e(t3.token)))(n2));
    };
    const n = (t3) => {
      $("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t3, this.appCheck.addTokenListener(this.o);
    };
    this.g.onInit((t3) => n(t3)), setTimeout(() => {
      if (!this.appCheck) {
        const t3 = this.g.getImmediate({
          optional: true
        });
        t3 ? n(t3) : $("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
      }
    }, 0);
  }
  getToken() {
    const t2 = this.forceRefresh;
    return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t2).then((t3) => t3 ? (B2(typeof t3.token == "string"), new X2(t3.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o);
  }
};
var tt = class {
  getToken() {
    return Promise.resolve(new X2(""));
  }
  invalidateToken() {
  }
  start(t2, e) {
  }
  shutdown() {
  }
};
var et = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.p(t3), this.T = (t3) => e.writeSequenceNumber(t3));
  }
  p(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.T && this.T(t2), t2;
  }
};
function nt(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
et.I = -1;
var st = class {
  static A() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = nt(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function it(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function rt(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function ot(t2) {
  return t2 + "\0";
}
var at = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new j(K2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new j(K2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new j(K2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new j(K2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return at.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return at.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new at(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? it(this.nanoseconds, t2.nanoseconds) : it(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var ct = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new ct(t2);
  }
  static min() {
    return new ct(new at(0, 0));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
function ut(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function ht(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function lt(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
var ft = class {
  constructor(t2, e, n) {
    e === void 0 ? e = 0 : e > t2.length && L2(), n === void 0 ? n = t2.length - e : n > t2.length - e && L2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return ft.comparator(this, t2) === 0;
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof ft ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var dt = class extends ft {
  construct(t2, e, n) {
    return new dt(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new j(K2.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new dt(e);
  }
  static emptyPath() {
    return new dt([]);
  }
};
var wt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var _t = class extends ft {
  construct(t2, e, n) {
    return new _t(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return wt.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), _t.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new _t(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (n.length === 0)
        throw new j(K2.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if (e2 === "\\") {
        if (s + 1 === t2.length)
          throw new j(K2.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if (e3 !== "\\" && e3 !== "." && e3 !== "`")
          throw new j(K2.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        e2 === "`" ? (r = !r, s++) : e2 !== "." || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new j(K2.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new _t(e);
  }
  static emptyPath() {
    return new _t([]);
  }
};
var mt = class {
  constructor(t2) {
    this.fields = t2, t2.sort(_t.comparator);
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return rt(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
function gt() {
  return typeof atob != "undefined";
}
var yt = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new yt(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new yt(e);
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return it(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
yt.EMPTY_BYTE_STRING = new yt("");
var pt = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Tt(t2) {
  if (B2(!!t2), typeof t2 == "string") {
    let e = 0;
    const n = pt.exec(t2);
    if (B2(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Et(t2.seconds),
    nanos: Et(t2.nanos)
  };
}
function Et(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function It(t2) {
  return typeof t2 == "string" ? yt.fromBase64String(t2) : yt.fromUint8Array(t2);
}
function At(t2) {
  var e, n;
  return ((n = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function Rt(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return At(e) ? Rt(e) : e;
}
function Pt(t2) {
  const e = Tt(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new at(e.seconds, e.nanos);
}
function bt(t2) {
  return t2 == null;
}
function vt(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function Vt(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !vt(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
var St = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new St(dt.fromString(t2));
  }
  static fromName(t2) {
    return new St(dt.fromString(t2).popFirst(5));
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  isEqual(t2) {
    return t2 !== null && dt.comparator(this.path, t2.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return dt.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new St(new dt(t2.slice()));
  }
};
function Dt(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? At(t2) ? 4 : 10 : L2();
}
function Ct(t2, e) {
  const n = Dt(t2);
  if (n !== Dt(e))
    return false;
  switch (n) {
    case 0:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return Pt(t2).isEqual(Pt(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = Tt(t3.timestampValue), s = Tt(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return It(t3.bytesValue).isEqual(It(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return Et(t3.geoPointValue.latitude) === Et(e2.geoPointValue.latitude) && Et(t3.geoPointValue.longitude) === Et(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return Et(t3.integerValue) === Et(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = Et(t3.doubleValue), s = Et(e2.doubleValue);
          return n2 === s ? vt(n2) === vt(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return rt(t2.arrayValue.values || [], e.arrayValue.values || [], Ct);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (ut(n2) !== ut(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (s[t4] === void 0 || !Ct(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return L2();
  }
}
function Nt(t2, e) {
  return (t2.values || []).find((t3) => Ct(t3, e)) !== void 0;
}
function kt(t2, e) {
  const n = Dt(t2), s = Dt(e);
  if (n !== s)
    return it(n, s);
  switch (n) {
    case 0:
      return 0;
    case 1:
      return it(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = Et(t3.integerValue || t3.doubleValue), s2 = Et(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return xt(t2.timestampValue, e.timestampValue);
    case 4:
      return xt(Pt(t2), Pt(e));
    case 5:
      return it(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = It(t3), s2 = It(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = it(n2[t4], s2[t4]);
          if (e3 !== 0)
            return e3;
        }
        return it(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = it(Et(t3.latitude), Et(e2.latitude));
        if (n2 !== 0)
          return n2;
        return it(Et(t3.longitude), Et(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = kt(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return it(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = it(s2[t4], r[t4]);
          if (e3 !== 0)
            return e3;
          const o = kt(n2[s2[t4]], i[r[t4]]);
          if (o !== 0)
            return o;
        }
        return it(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw L2();
  }
}
function xt(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return it(t2, e);
  const n = Tt(t2), s = Tt(e), i = it(n.seconds, s.seconds);
  return i !== 0 ? i : it(n.nanos, s.nanos);
}
function $t(t2) {
  return Ft(t2);
}
function Ft(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = Tt(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? It(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, St.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += Ft(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${Ft(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : L2();
  var e, n;
}
function Ot(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function Mt(t2) {
  return !!t2 && "integerValue" in t2;
}
function Lt(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Bt(t2) {
  return !!t2 && "nullValue" in t2;
}
function Ut(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function qt(t2) {
  return !!t2 && "mapValue" in t2;
}
function Kt(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && typeof t2.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return ht(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = Kt(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Kt(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
var jt = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new jt({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !qt(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = Kt(e);
  }
  setAll(t2) {
    let e = _t.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = Kt(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    qt(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return Ct(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      qt(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    ht(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new jt(Kt(this.value));
  }
};
function Qt(t2) {
  const e = [];
  return ht(t2.fields, (t3, n) => {
    const s = new _t([t3]);
    if (qt(n)) {
      const t4 = Qt(n.mapValue).fields;
      if (t4.length === 0)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new mt(e);
}
var Wt = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.documentType = e, this.version = n, this.data = s, this.documentState = i;
  }
  static newInvalidDocument(t2) {
    return new Wt(t2, 0, ct.min(), jt.empty(), 0);
  }
  static newFoundDocument(t2, e, n) {
    return new Wt(t2, 1, e, n, 0);
  }
  static newNoDocument(t2, e) {
    return new Wt(t2, 2, e, jt.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new Wt(t2, 3, e, jt.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = jt.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = jt.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t2) {
    return t2 instanceof Wt && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  clone() {
    return new Wt(this.key, this.documentType, this.version, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var Gt = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.R = null;
  }
};
function zt(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new Gt(t2, e, n, s, i, r, o);
}
function Ht(t2) {
  const e = q2(t2);
  if (e.R === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => te(t4)).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), bt(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += he(e.startAt)), e.endAt && (t3 += "|ub:", t3 += he(e.endAt)), e.R = t3;
  }
  return e.R;
}
function Jt(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${$t(e2.value)}`;
    var e2;
  }).join(", ")}]`), bt(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: " + he(t2.startAt)), t2.endAt && (e += ", endAt: " + he(t2.endAt)), `Target(${e})`;
}
function Yt(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!fe(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !Ct(n.value, s.value))
      return false;
  var n, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!we(t2.startAt, e.startAt) && we(t2.endAt, e.endAt)));
}
function Xt(t2) {
  return St.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
var Zt = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? e === "in" || e === "not-in" ? this.P(t2, e, n) : new ee(t2, e, n) : e === "array-contains" ? new re(t2, n) : e === "in" ? new oe(t2, n) : e === "not-in" ? new ae(t2, n) : e === "array-contains-any" ? new ce(t2, n) : new Zt(t2, e, n);
  }
  static P(t2, e, n) {
    return e === "in" ? new ne(t2, n) : new se(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return this.op === "!=" ? e !== null && this.v(kt(e, this.value)) : e !== null && Dt(this.value) === Dt(e) && this.v(kt(e, this.value));
  }
  v(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return t2 === 0;
      case "!=":
        return t2 !== 0;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return L2();
    }
  }
  V() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
function te(t2) {
  return t2.field.canonicalString() + t2.op.toString() + $t(t2.value);
}
var ee = class extends Zt {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = St.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = St.comparator(t2.key, this.key);
    return this.v(e);
  }
};
var ne = class extends Zt {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = ie("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var se = class extends Zt {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = ie("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function ie(t2, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((t3) => St.fromName(t3.referenceValue));
}
var re = class extends Zt {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return Lt(e) && Nt(e.arrayValue, this.value);
  }
};
var oe = class extends Zt {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return e !== null && Nt(this.value.arrayValue, e);
  }
};
var ae = class extends Zt {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (Nt(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return e !== null && !Nt(this.value.arrayValue, e);
  }
};
var ce = class extends Zt {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!Lt(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => Nt(this.value.arrayValue, t3));
  }
};
var ue = class {
  constructor(t2, e) {
    this.position = t2, this.before = e;
  }
};
function he(t2) {
  return `${t2.before ? "b" : "a"}:${t2.position.map((t3) => $t(t3)).join(",")}`;
}
var le = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function fe(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function de(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = St.comparator(St.fromName(o.referenceValue), n.key);
    else {
      s = kt(o, n.data.field(r.field));
    }
    if (r.dir === "desc" && (s *= -1), s !== 0)
      break;
  }
  return t2.before ? s <= 0 : s < 0;
}
function we(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.before !== e.before || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!Ct(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var _e = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, a = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = a, this.S = null, this.D = null, this.startAt, this.endAt;
  }
};
function me(t2, e, n, s, i, r, o, a) {
  return new _e(t2, e, n, s, i, r, o, a);
}
function ge(t2) {
  return new _e(t2);
}
function ye(t2) {
  return !bt(t2.limit) && t2.limitType === "F";
}
function pe(t2) {
  return !bt(t2.limit) && t2.limitType === "L";
}
function Te(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function Ee(t2) {
  for (const e of t2.filters)
    if (e.V())
      return e.field;
  return null;
}
function Ie(t2) {
  return t2.collectionGroup !== null;
}
function Ae(t2) {
  const e = q2(t2);
  if (e.S === null) {
    e.S = [];
    const t3 = Ee(e), n = Te(e);
    if (t3 !== null && n === null)
      t3.isKeyField() || e.S.push(new le(t3)), e.S.push(new le(_t.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.S.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.S.push(new le(_t.keyField(), t5));
      }
    }
  }
  return e.S;
}
function Re(t2) {
  const e = q2(t2);
  if (!e.D)
    if (e.limitType === "F")
      e.D = zt(e.path, e.collectionGroup, Ae(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of Ae(e)) {
        const e2 = n2.dir === "desc" ? "asc" : "desc";
        t3.push(new le(n2.field, e2));
      }
      const n = e.endAt ? new ue(e.endAt.position, !e.endAt.before) : null, s = e.startAt ? new ue(e.startAt.position, !e.startAt.before) : null;
      e.D = zt(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.D;
}
function Pe(t2, e, n) {
  return new _e(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function be(t2, e) {
  return Yt(Re(t2), Re(e)) && t2.limitType === e.limitType;
}
function ve(t2) {
  return `${Ht(Re(t2))}|lt:${t2.limitType}`;
}
function Ve(t2) {
  return `Query(target=${Jt(Re(t2))}; limitType=${t2.limitType})`;
}
function Se(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : St.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && e2.data.field(n.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !de(t3.startAt, Ae(t3), e2))
      return false;
    if (t3.endAt && de(t3.endAt, Ae(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function De(t2) {
  return (e, n) => {
    let s = false;
    for (const i of Ae(t2)) {
      const t3 = Ce(i, e, n);
      if (t3 !== 0)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function Ce(t2, e, n) {
  const s = t2.field.isKeyField() ? St.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return s2 !== null && i !== null ? kt(s2, i) : L2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return L2();
  }
}
function Ne(t2, e) {
  if (t2.C) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: vt(e) ? "-0" : e
  };
}
function ke(t2) {
  return {
    integerValue: "" + t2
  };
}
function xe(t2, e) {
  return Vt(e) ? ke(e) : Ne(t2, e);
}
var $e = class {
  constructor() {
    this._ = void 0;
  }
};
function Fe(t2, e, n) {
  return t2 instanceof Le ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof Be ? Ue(t2, e) : t2 instanceof qe ? Ke(t2, e) : function(t3, e2) {
    const n2 = Me(t3, e2), s = Qe(n2) + Qe(t3.N);
    return Mt(n2) && Mt(t3.N) ? ke(s) : Ne(t3.k, s);
  }(t2, e);
}
function Oe(t2, e, n) {
  return t2 instanceof Be ? Ue(t2, e) : t2 instanceof qe ? Ke(t2, e) : n;
}
function Me(t2, e) {
  return t2 instanceof je ? Mt(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var Le = class extends $e {
};
var Be = class extends $e {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function Ue(t2, e) {
  const n = We(e);
  for (const e2 of t2.elements)
    n.some((t3) => Ct(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var qe = class extends $e {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function Ke(t2, e) {
  let n = We(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !Ct(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var je = class extends $e {
  constructor(t2, e) {
    super(), this.k = t2, this.N = e;
  }
};
function Qe(t2) {
  return Et(t2.integerValue || t2.doubleValue);
}
function We(t2) {
  return Lt(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var Ge = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function ze(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof Be && e2 instanceof Be || t3 instanceof qe && e2 instanceof qe ? rt(t3.elements, e2.elements, Ct) : t3 instanceof je && e2 instanceof je ? Ct(t3.N, e2.N) : t3 instanceof Le && e2 instanceof Le;
  }(t2.transform, e.transform);
}
var He = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var Je = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new Je();
  }
  static exists(t2) {
    return new Je(void 0, t2);
  }
  static updateTime(t2) {
    return new Je(t2);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function Ye(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
var Xe = class {
};
function Ze(t2, e, n) {
  t2 instanceof rn ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = cn(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof on ? function(t3, e2, n2) {
    if (!Ye(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = cn(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(an(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function tn(t2, e, n) {
  t2 instanceof rn ? function(t3, e2, n2) {
    if (!Ye(t3.precondition, e2))
      return;
    const s = t3.value.clone(), i = un(t3.fieldTransforms, n2, e2);
    s.setAll(i), e2.convertToFoundDocument(sn(e2), s).setHasLocalMutations();
  }(t2, e, n) : t2 instanceof on ? function(t3, e2, n2) {
    if (!Ye(t3.precondition, e2))
      return;
    const s = un(t3.fieldTransforms, n2, e2), i = e2.data;
    i.setAll(an(t3)), i.setAll(s), e2.convertToFoundDocument(sn(e2), i).setHasLocalMutations();
  }(t2, e, n) : function(t3, e2) {
    Ye(t3.precondition, e2) && e2.convertToNoDocument(ct.min());
  }(t2, e);
}
function en(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = Me(s.transform, t3 || null);
    i != null && (n == null && (n = jt.empty()), n.set(s.field, i));
  }
  return n || null;
}
function nn(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && rt(t3, e2, (t4, e3) => ze(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
function sn(t2) {
  return t2.isFoundDocument() ? t2.version : ct.min();
}
var rn = class extends Xe {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
};
var on = class extends Xe {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
};
function an(t2) {
  const e = new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function cn(t2, e, n) {
  const s = new Map();
  B2(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, a = e.data.field(r.field);
    s.set(r.field, Oe(o, a, n[i]));
  }
  return s;
}
function un(t2, e, n) {
  const s = new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, Fe(t3, r, e));
  }
  return s;
}
var hn = class extends Xe {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
};
var ln = class extends Xe {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
};
var fn = class {
  constructor(t2) {
    this.count = t2;
  }
};
var dn;
var wn;
function _n(t2) {
  switch (t2) {
    default:
      return L2();
    case K2.CANCELLED:
    case K2.UNKNOWN:
    case K2.DEADLINE_EXCEEDED:
    case K2.RESOURCE_EXHAUSTED:
    case K2.INTERNAL:
    case K2.UNAVAILABLE:
    case K2.UNAUTHENTICATED:
      return false;
    case K2.INVALID_ARGUMENT:
    case K2.NOT_FOUND:
    case K2.ALREADY_EXISTS:
    case K2.PERMISSION_DENIED:
    case K2.FAILED_PRECONDITION:
    case K2.ABORTED:
    case K2.OUT_OF_RANGE:
    case K2.UNIMPLEMENTED:
    case K2.DATA_LOSS:
      return true;
  }
}
function mn(t2) {
  if (t2 === void 0)
    return F2("GRPC error has no .code"), K2.UNKNOWN;
  switch (t2) {
    case dn.OK:
      return K2.OK;
    case dn.CANCELLED:
      return K2.CANCELLED;
    case dn.UNKNOWN:
      return K2.UNKNOWN;
    case dn.DEADLINE_EXCEEDED:
      return K2.DEADLINE_EXCEEDED;
    case dn.RESOURCE_EXHAUSTED:
      return K2.RESOURCE_EXHAUSTED;
    case dn.INTERNAL:
      return K2.INTERNAL;
    case dn.UNAVAILABLE:
      return K2.UNAVAILABLE;
    case dn.UNAUTHENTICATED:
      return K2.UNAUTHENTICATED;
    case dn.INVALID_ARGUMENT:
      return K2.INVALID_ARGUMENT;
    case dn.NOT_FOUND:
      return K2.NOT_FOUND;
    case dn.ALREADY_EXISTS:
      return K2.ALREADY_EXISTS;
    case dn.PERMISSION_DENIED:
      return K2.PERMISSION_DENIED;
    case dn.FAILED_PRECONDITION:
      return K2.FAILED_PRECONDITION;
    case dn.ABORTED:
      return K2.ABORTED;
    case dn.OUT_OF_RANGE:
      return K2.OUT_OF_RANGE;
    case dn.UNIMPLEMENTED:
      return K2.UNIMPLEMENTED;
    case dn.DATA_LOSS:
      return K2.DATA_LOSS;
    default:
      return L2();
  }
}
(wn = dn || (dn = {}))[wn.OK = 0] = "OK", wn[wn.CANCELLED = 1] = "CANCELLED", wn[wn.UNKNOWN = 2] = "UNKNOWN", wn[wn.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", wn[wn.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", wn[wn.NOT_FOUND = 5] = "NOT_FOUND", wn[wn.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", wn[wn.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", wn[wn.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", wn[wn.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", wn[wn.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", wn[wn.ABORTED = 10] = "ABORTED", wn[wn.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", wn[wn.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", wn[wn.INTERNAL = 13] = "INTERNAL", wn[wn.UNAVAILABLE = 14] = "UNAVAILABLE", wn[wn.DATA_LOSS = 15] = "DATA_LOSS";
var gn = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || pn.EMPTY;
  }
  insert(t2, e) {
    return new gn(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, pn.BLACK, null, null));
  }
  remove(t2) {
    return new gn(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, pn.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (n === 0)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (s === 0)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new yn(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new yn(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new yn(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new yn(this.root, t2, this.comparator, true);
  }
};
var yn = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (i === 0) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var pn = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = n != null ? n : pn.RED, this.left = s != null ? s : pn.EMPTY, this.right = i != null ? i : pn.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new pn(t2 != null ? t2 : this.key, e != null ? e : this.value, n != null ? n : this.color, s != null ? s : this.left, i != null ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : i === 0 ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return pn.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), e(t2, s.key) === 0) {
        if (s.right.isEmpty())
          return pn.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, pn.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, pn.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw L2();
    if (this.right.isRed())
      throw L2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw L2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
pn.EMPTY = null, pn.RED = true, pn.BLACK = false;
pn.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw L2();
  }
  get value() {
    throw L2();
  }
  get color() {
    throw L2();
  }
  get left() {
    throw L2();
  }
  get right() {
    throw L2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new pn(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var Tn = class {
  constructor(t2) {
    this.comparator = t2, this.data = new gn(this.comparator);
  }
  has(t2) {
    return this.data.get(t2) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new En(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new En(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof Tn))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (this.comparator(t3, s) !== 0)
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new Tn(this.comparator);
    return e.data = t2, e;
  }
};
var En = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
var In = new gn(St.comparator);
function An() {
  return In;
}
var Rn = new gn(St.comparator);
function Pn() {
  return Rn;
}
var bn = new gn(St.comparator);
function vn() {
  return bn;
}
var Vn = new Tn(St.comparator);
function Sn(...t2) {
  let e = Vn;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var Dn = new Tn(it);
function Cn() {
  return Dn;
}
var Nn = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n = new Map();
    return n.set(t2, kn.createSynthesizedTargetChangeForCurrentChange(t2, e)), new Nn(ct.min(), n, Cn(), An(), Sn());
  }
};
var kn = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new kn(yt.EMPTY_BYTE_STRING, e, Sn(), Sn(), Sn());
  }
};
var xn = class {
  constructor(t2, e, n, s) {
    this.$ = t2, this.removedTargetIds = e, this.key = n, this.F = s;
  }
};
var $n = class {
  constructor(t2, e) {
    this.targetId = t2, this.O = e;
  }
};
var Fn = class {
  constructor(t2, e, n = yt.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var On = class {
  constructor() {
    this.M = 0, this.L = Bn(), this.B = yt.EMPTY_BYTE_STRING, this.U = false, this.q = true;
  }
  get current() {
    return this.U;
  }
  get resumeToken() {
    return this.B;
  }
  get K() {
    return this.M !== 0;
  }
  get j() {
    return this.q;
  }
  W(t2) {
    t2.approximateByteSize() > 0 && (this.q = true, this.B = t2);
  }
  G() {
    let t2 = Sn(), e = Sn(), n = Sn();
    return this.L.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          L2();
      }
    }), new kn(this.B, this.U, t2, e, n);
  }
  H() {
    this.q = false, this.L = Bn();
  }
  J(t2, e) {
    this.q = true, this.L = this.L.insert(t2, e);
  }
  Y(t2) {
    this.q = true, this.L = this.L.remove(t2);
  }
  X() {
    this.M += 1;
  }
  Z() {
    this.M -= 1;
  }
  tt() {
    this.q = true, this.U = true;
  }
};
var Mn = class {
  constructor(t2) {
    this.et = t2, this.nt = new Map(), this.st = An(), this.it = Ln(), this.rt = new Tn(it);
  }
  ot(t2) {
    for (const e of t2.$)
      t2.F && t2.F.isFoundDocument() ? this.at(e, t2.F) : this.ct(e, t2.key, t2.F);
    for (const e of t2.removedTargetIds)
      this.ct(e, t2.key, t2.F);
  }
  ut(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.ht(e);
      switch (t2.state) {
        case 0:
          this.lt(e) && n.W(t2.resumeToken);
          break;
        case 1:
          n.Z(), n.K || n.H(), n.W(t2.resumeToken);
          break;
        case 2:
          n.Z(), n.K || this.removeTarget(e);
          break;
        case 3:
          this.lt(e) && (n.tt(), n.W(t2.resumeToken));
          break;
        case 4:
          this.lt(e) && (this.ft(e), n.W(t2.resumeToken));
          break;
        default:
          L2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.nt.forEach((t3, n) => {
      this.lt(n) && e(n);
    });
  }
  dt(t2) {
    const e = t2.targetId, n = t2.O.count, s = this.wt(e);
    if (s) {
      const t3 = s.target;
      if (Xt(t3))
        if (n === 0) {
          const n2 = new St(t3.path);
          this.ct(e, n2, Wt.newNoDocument(n2, ct.min()));
        } else
          B2(n === 1);
      else {
        this._t(e) !== n && (this.ft(e), this.rt = this.rt.add(e));
      }
    }
  }
  gt(t2) {
    const e = new Map();
    this.nt.forEach((n2, s2) => {
      const i = this.wt(s2);
      if (i) {
        if (n2.current && Xt(i.target)) {
          const e2 = new St(i.target.path);
          this.st.get(e2) !== null || this.yt(s2, e2) || this.ct(s2, e2, Wt.newNoDocument(e2, t2));
        }
        n2.j && (e.set(s2, n2.G()), n2.H());
      }
    });
    let n = Sn();
    this.it.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.wt(t4);
        return !e3 || e3.purpose === 2 || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    });
    const s = new Nn(t2, e, this.rt, this.st, n);
    return this.st = An(), this.it = Ln(), this.rt = new Tn(it), s;
  }
  at(t2, e) {
    if (!this.lt(t2))
      return;
    const n = this.yt(t2, e.key) ? 2 : 0;
    this.ht(t2).J(e.key, n), this.st = this.st.insert(e.key, e), this.it = this.it.insert(e.key, this.Tt(e.key).add(t2));
  }
  ct(t2, e, n) {
    if (!this.lt(t2))
      return;
    const s = this.ht(t2);
    this.yt(t2, e) ? s.J(e, 1) : s.Y(e), this.it = this.it.insert(e, this.Tt(e).delete(t2)), n && (this.st = this.st.insert(e, n));
  }
  removeTarget(t2) {
    this.nt.delete(t2);
  }
  _t(t2) {
    const e = this.ht(t2).G();
    return this.et.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  X(t2) {
    this.ht(t2).X();
  }
  ht(t2) {
    let e = this.nt.get(t2);
    return e || (e = new On(), this.nt.set(t2, e)), e;
  }
  Tt(t2) {
    let e = this.it.get(t2);
    return e || (e = new Tn(it), this.it = this.it.insert(t2, e)), e;
  }
  lt(t2) {
    const e = this.wt(t2) !== null;
    return e || $("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  wt(t2) {
    const e = this.nt.get(t2);
    return e && e.K ? null : this.et.Et(t2);
  }
  ft(t2) {
    this.nt.set(t2, new On());
    this.et.getRemoteKeysForTarget(t2).forEach((e) => {
      this.ct(t2, e, null);
    });
  }
  yt(t2, e) {
    return this.et.getRemoteKeysForTarget(t2).has(e);
  }
};
function Ln() {
  return new gn(St.comparator);
}
function Bn() {
  return new gn(St.comparator);
}
var Un = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var qn = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var Kn = class {
  constructor(t2, e) {
    this.databaseId = t2, this.C = e;
  }
};
function jn(t2, e) {
  if (t2.C) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Qn(t2, e) {
  return t2.C ? e.toBase64() : e.toUint8Array();
}
function Wn(t2, e) {
  return jn(t2, e.toTimestamp());
}
function Gn(t2) {
  return B2(!!t2), ct.fromTimestamp(function(t3) {
    const e = Tt(t3);
    return new at(e.seconds, e.nanos);
  }(t2));
}
function zn(t2, e) {
  return function(t3) {
    return new dt(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function Hn(t2) {
  const e = dt.fromString(t2);
  return B2(As(e)), e;
}
function Jn(t2, e) {
  return zn(t2.databaseId, e.path);
}
function Yn(t2, e) {
  const n = Hn(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new j(K2.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new j(K2.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new St(es(n));
}
function Xn(t2, e) {
  return zn(t2.databaseId, e);
}
function Zn(t2) {
  const e = Hn(t2);
  return e.length === 4 ? dt.emptyPath() : es(e);
}
function ts(t2) {
  return new dt(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function es(t2) {
  return B2(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function ns(t2, e, n) {
  return {
    name: Jn(t2, e),
    fields: n.value.mapValue.fields
  };
}
function ss(t2, e, n) {
  const s = Yn(t2, e.name), i = Gn(e.updateTime), r = new jt({
    mapValue: {
      fields: e.fields
    }
  }), o = Wt.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function is(t2, e) {
  return "found" in e ? function(t3, e2) {
    B2(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = Yn(t3, e2.found.name), s = Gn(e2.found.updateTime), i = new jt({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return Wt.newFoundDocument(n, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    B2(!!e2.missing), B2(!!e2.readTime);
    const n = Yn(t3, e2.missing), s = Gn(e2.readTime);
    return Wt.newNoDocument(n, s);
  }(t2, e) : L2();
}
function rs(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : L2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.C ? (B2(e2 === void 0 || typeof e2 == "string"), yt.fromBase64String(e2 || "")) : (B2(e2 === void 0 || e2 instanceof Uint8Array), yt.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, a = o && function(t3) {
      const e2 = t3.code === void 0 ? K2.UNKNOWN : mn(t3.code);
      return new j(e2, t3.message || "");
    }(o);
    n = new Fn(s, i, r, a || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = Yn(t2, s.document.name), r = Gn(s.document.updateTime), o = new jt({
      mapValue: {
        fields: s.document.fields
      }
    }), a = Wt.newFoundDocument(i, r, o), c = s.targetIds || [], u = s.removedTargetIds || [];
    n = new xn(c, u, a.key, a);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = Yn(t2, s.document), r = s.readTime ? Gn(s.readTime) : ct.min(), o = Wt.newNoDocument(i, r), a = s.removedTargetIds || [];
    n = new xn([], a, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = Yn(t2, s.document), r = s.removedTargetIds || [];
    n = new xn([], r, i, null);
  } else {
    if (!("filter" in e))
      return L2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new fn(s), r = t3.targetId;
      n = new $n(r, i);
    }
  }
  return n;
}
function os(t2, e) {
  let n;
  if (e instanceof rn)
    n = {
      update: ns(t2, e.key, e.value)
    };
  else if (e instanceof hn)
    n = {
      delete: Jn(t2, e.key)
    };
  else if (e instanceof on)
    n = {
      update: ns(t2, e.key, e.data),
      updateMask: Is(e.fieldMask)
    };
  else {
    if (!(e instanceof ln))
      return L2();
    n = {
      verify: Jn(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof Le)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof Be)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof qe)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof je)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.N
      };
    throw L2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: Wn(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : L2();
  }(t2, e.precondition)), n;
}
function as(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return t3.updateTime !== void 0 ? Je.updateTime(Gn(t3.updateTime)) : t3.exists !== void 0 ? Je.exists(t3.exists) : Je.none();
  }(e.currentDocument) : Je.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      B2(e3.setToServerValue === "REQUEST_TIME"), n2 = new Le();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new Be(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new qe(t4);
    } else
      "increment" in e3 ? n2 = new je(t3, e3.increment) : L2();
    const s2 = _t.fromServerFormat(e3.fieldPath);
    return new Ge(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = Yn(t2, e.update.name), r = new jt({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new mt(e2.map((t5) => _t.fromServerFormat(t5)));
      }(e.updateMask);
      return new on(i, r, t3, n, s);
    }
    return new rn(i, r, n, s);
  }
  if (e.delete) {
    const s2 = Yn(t2, e.delete);
    return new hn(s2, n);
  }
  if (e.verify) {
    const s2 = Yn(t2, e.verify);
    return new ln(s2, n);
  }
  return L2();
}
function cs(t2, e) {
  return t2 && t2.length > 0 ? (B2(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? Gn(t4.updateTime) : Gn(e2);
    return n.isEqual(ct.min()) && (n = Gn(e2)), new He(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function us(t2, e) {
  return {
    documents: [Xn(t2, e.path)]
  };
}
function hs(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  e.collectionGroup !== null ? (n.parent = Xn(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = Xn(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (Ut(t5.value))
          return {
            unaryFilter: {
              field: ys(t5.field),
              op: "IS_NAN"
            }
          };
        if (Bt(t5.value))
          return {
            unaryFilter: {
              field: ys(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (Ut(t5.value))
          return {
            unaryFilter: {
              field: ys(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Bt(t5.value))
          return {
            unaryFilter: {
              field: ys(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: ys(t5.field),
          op: gs(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: ys(t5.field),
        direction: ms(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.C || bt(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  return o !== null && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = ws(e.startAt)), e.endAt && (n.structuredQuery.endAt = ws(e.endAt)), n;
}
function ls(t2) {
  let e = Zn(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    B2(s === 1);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = ds(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new le(ps(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let a = null;
  n.limit && (a = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, bt(e2) ? null : e2;
  }(n.limit));
  let c = null;
  n.startAt && (c = _s(n.startAt));
  let u = null;
  return n.endAt && (u = _s(n.endAt)), me(e, i, o, r, a, "F", c, u);
}
function fs(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return L2();
    }
  }(0, e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function ds(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [Es(t2)] : t2.fieldFilter !== void 0 ? [Ts(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => ds(t3)).reduce((t3, e) => t3.concat(e)) : L2() : [];
}
function ws(t2) {
  return {
    before: t2.before,
    values: t2.position
  };
}
function _s(t2) {
  const e = !!t2.before, n = t2.values || [];
  return new ue(n, e);
}
function ms(t2) {
  return Un[t2];
}
function gs(t2) {
  return qn[t2];
}
function ys(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function ps(t2) {
  return _t.fromServerFormat(t2.fieldPath);
}
function Ts(t2) {
  return Zt.create(ps(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      default:
        return L2();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function Es(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = ps(t2.unaryFilter.field);
      return Zt.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = ps(t2.unaryFilter.field);
      return Zt.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = ps(t2.unaryFilter.field);
      return Zt.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = ps(t2.unaryFilter.field);
      return Zt.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    default:
      return L2();
  }
}
function Is(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function As(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
function Rs(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = bs(e)), e = Ps(t2.get(n), e);
  return bs(e);
}
function Ps(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function bs(t2) {
  return t2 + "";
}
function vs(t2) {
  const e = t2.length;
  if (B2(e >= 2), e === 2)
    return B2(t2.charAt(0) === "" && t2.charAt(1) === ""), dt.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t2.indexOf("", r);
    (e2 < 0 || e2 > n) && L2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n2 = t2.substring(r, e2);
        let o;
        i.length === 0 ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r, e2 + 1);
        break;
      default:
        L2();
    }
    r = e2 + 2;
  }
  return new dt(s);
}
var Vs = class {
  constructor(t2, e) {
    this.seconds = t2, this.nanoseconds = e;
  }
};
var Ss = class {
  constructor(t2, e, n) {
    this.ownerId = t2, this.allowTabSynchronization = e, this.leaseTimestampMs = n;
  }
};
Ss.store = "owner", Ss.key = "owner";
var Ds = class {
  constructor(t2, e, n) {
    this.userId = t2, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n;
  }
};
Ds.store = "mutationQueues", Ds.keyPath = "userId";
var Cs = class {
  constructor(t2, e, n, s, i) {
    this.userId = t2, this.batchId = e, this.localWriteTimeMs = n, this.baseMutations = s, this.mutations = i;
  }
};
Cs.store = "mutations", Cs.keyPath = "batchId", Cs.userMutationsIndex = "userMutationsIndex", Cs.userMutationsKeyPath = ["userId", "batchId"];
var Ns = class {
  constructor() {
  }
  static prefixForUser(t2) {
    return [t2];
  }
  static prefixForPath(t2, e) {
    return [t2, Rs(e)];
  }
  static key(t2, e, n) {
    return [t2, Rs(e), n];
  }
};
Ns.store = "documentMutations", Ns.PLACEHOLDER = new Ns();
var ks = class {
  constructor(t2, e) {
    this.path = t2, this.readTime = e;
  }
};
var xs = class {
  constructor(t2, e) {
    this.path = t2, this.version = e;
  }
};
var $s = class {
  constructor(t2, e, n, s, i, r) {
    this.unknownDocument = t2, this.noDocument = e, this.document = n, this.hasCommittedMutations = s, this.readTime = i, this.parentPath = r;
  }
};
$s.store = "remoteDocuments", $s.readTimeIndex = "readTimeIndex", $s.readTimeIndexPath = "readTime", $s.collectionReadTimeIndex = "collectionReadTimeIndex", $s.collectionReadTimeIndexPath = ["parentPath", "readTime"];
var Fs = class {
  constructor(t2) {
    this.byteSize = t2;
  }
};
Fs.store = "remoteDocumentGlobal", Fs.key = "remoteDocumentGlobalKey";
var Os = class {
  constructor(t2, e, n, s, i, r, o) {
    this.targetId = t2, this.canonicalId = e, this.readTime = n, this.resumeToken = s, this.lastListenSequenceNumber = i, this.lastLimboFreeSnapshotVersion = r, this.query = o;
  }
};
Os.store = "targets", Os.keyPath = "targetId", Os.queryTargetsIndexName = "queryTargetsIndex", Os.queryTargetsKeyPath = ["canonicalId", "targetId"];
var Ms = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.path = e, this.sequenceNumber = n;
  }
};
Ms.store = "targetDocuments", Ms.keyPath = ["targetId", "path"], Ms.documentTargetsIndex = "documentTargetsIndex", Ms.documentTargetsKeyPath = ["path", "targetId"];
var Ls = class {
  constructor(t2, e, n, s) {
    this.highestTargetId = t2, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n, this.targetCount = s;
  }
};
Ls.key = "targetGlobalKey", Ls.store = "targetGlobal";
var Bs = class {
  constructor(t2, e) {
    this.collectionId = t2, this.parent = e;
  }
};
Bs.store = "collectionParents", Bs.keyPath = ["collectionId", "parent"];
var Us = class {
  constructor(t2, e, n, s) {
    this.clientId = t2, this.updateTimeMs = e, this.networkEnabled = n, this.inForeground = s;
  }
};
Us.store = "clientMetadata", Us.keyPath = "clientId";
var qs = class {
  constructor(t2, e, n) {
    this.bundleId = t2, this.createTime = e, this.version = n;
  }
};
qs.store = "bundles", qs.keyPath = "bundleId";
var Ks = class {
  constructor(t2, e, n) {
    this.name = t2, this.readTime = e, this.bundledQuery = n;
  }
};
Ks.store = "namedQueries", Ks.keyPath = "name";
var js = [...[...[...[...[Ds.store, Cs.store, Ns.store, $s.store, Os.store, Ss.store, Ls.store, Ms.store], Us.store], Fs.store], Bs.store], qs.store, Ks.store];
var Qs = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var Ws = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
var Gs = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && L2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new Gs((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof Gs ? e : Gs.resolve(e);
    } catch (t3) {
      return Gs.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : Gs.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : Gs.reject(e);
  }
  static resolve(t2) {
    return new Gs((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new Gs((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new Gs((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = Gs.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? Gs.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
};
var zs = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.It = new Q2(), this.transaction.oncomplete = () => {
      this.It.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.It.reject(new Ys(t2, e.error)) : this.It.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = ni(e2.target.error);
      this.It.reject(new Ys(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new zs(e, t2.transaction(s, n));
    } catch (t3) {
      throw new Ys(e, t3);
    }
  }
  get At() {
    return this.It.promise;
  }
  abort(t2) {
    t2 && this.It.reject(t2), this.aborted || ($("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new Zs(e);
  }
};
var Hs = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.Rt = n;
    Hs.Pt(getUA()) === 12.2 && F2("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return $("SimpleDb", "Removing database:", t2), ti(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static bt() {
    if (!isIndexedDBAvailable())
      return false;
    if (Hs.vt())
      return true;
    const t2 = getUA(), e = Hs.Pt(t2), n = 0 < e && e < 10, s = Hs.Vt(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static vt() {
    var t2;
    return typeof process != "undefined" && ((t2 = process.env) === null || t2 === void 0 ? void 0 : t2.St) === "YES";
  }
  static Dt(t2, e) {
    return t2.store(e);
  }
  static Pt(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static Vt(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async Ct(t2) {
    return this.db || ($("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new Ys(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        s2.name === "VersionError" ? n(new j(K2.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : s2.name === "InvalidStateError" ? n(new j(K2.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + s2)) : n(new Ys(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        $("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.Rt.Nt(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          $("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.kt && (this.db.onversionchange = (t3) => this.kt(t3)), this.db;
  }
  xt(t2) {
    this.kt = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = e === "readonly";
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.Ct(t2);
        const e2 = zs.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).catch((t3) => (e2.abort(t3), Gs.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.At, r2;
      } catch (t3) {
        const e2 = t3.name !== "FirebaseError" && r < 3;
        if ($("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", e2), this.close(), !e2)
          return Promise.reject(t3);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var Js = class {
  constructor(t2) {
    this.$t = t2, this.Ft = false, this.Ot = null;
  }
  get isDone() {
    return this.Ft;
  }
  get Mt() {
    return this.Ot;
  }
  set cursor(t2) {
    this.$t = t2;
  }
  done() {
    this.Ft = true;
  }
  Lt(t2) {
    this.Ot = t2;
  }
  delete() {
    return ti(this.$t.delete());
  }
};
var Ys = class extends j {
  constructor(t2, e) {
    super(K2.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function Xs(t2) {
  return t2.name === "IndexedDbTransactionError";
}
var Zs = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return e !== void 0 ? ($("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : ($("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), ti(n);
  }
  add(t2) {
    $("SimpleDb", "ADD", this.store.name, t2, t2);
    return ti(this.store.add(t2));
  }
  get(t2) {
    return ti(this.store.get(t2)).next((e) => (e === void 0 && (e = null), $("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    $("SimpleDb", "DELETE", this.store.name, t2);
    return ti(this.store.delete(t2));
  }
  count() {
    $("SimpleDb", "COUNT", this.store.name);
    return ti(this.store.count());
  }
  Bt(t2, e) {
    const n = this.cursor(this.options(t2, e)), s = [];
    return this.Ut(n, (t3, e2) => {
      s.push(e2);
    }).next(() => s);
  }
  qt(t2, e) {
    $("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.Kt = false;
    const s = this.cursor(n);
    return this.Ut(s, (t3, e2, n2) => n2.delete());
  }
  jt(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.Ut(s, e);
  }
  Qt(t2) {
    const e = this.cursor({});
    return new Gs((n, s) => {
      e.onerror = (t3) => {
        const e2 = ni(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  Ut(t2, e) {
    const n = [];
    return new Gs((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new Js(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof Gs) {
          const t4 = o.catch((t5) => (r.done(), Gs.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : r.Mt === null ? i2.continue() : i2.continue(r.Mt);
      };
    }).next(() => Gs.waitFor(n));
  }
  options(t2, e) {
    let n;
    return t2 !== void 0 && (typeof t2 == "string" ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.Kt ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function ti(t2) {
  return new Gs((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = ni(t3.target.error);
      n(e2);
    };
  });
}
var ei = false;
function ni(t2) {
  const e = Hs.Pt(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new j("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return ei || (ei = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var si = class extends Ws {
  constructor(t2, e) {
    super(), this.Wt = t2, this.currentSequenceNumber = e;
  }
};
function ii(t2, e) {
  const n = q2(t2);
  return Hs.Dt(n.Wt, e);
}
var ri = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        Ze(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2) {
    for (const e of this.baseMutations)
      e.key.isEqual(t2.key) && tn(e, t2, this.localWriteTime);
    for (const e of this.mutations)
      e.key.isEqual(t2.key) && tn(e, t2, this.localWriteTime);
  }
  applyToLocalDocumentSet(t2) {
    this.mutations.forEach((e) => {
      const n = t2.get(e.key), s = n;
      this.applyToLocalView(s), n.isValidDocument() || s.convertToNoDocument(ct.min());
    });
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), Sn());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && rt(this.mutations, t2.mutations, (t3, e) => nn(t3, e)) && rt(this.baseMutations, t2.baseMutations, (t3, e) => nn(t3, e));
  }
};
var oi = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    B2(t2.mutations.length === n.length);
    let s = vn();
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new oi(t2, e, n, s);
  }
};
var ai = class {
  constructor(t2, e, n, s, i = ct.min(), r = ct.min(), o = yt.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new ai(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new ai(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new ai(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var ci = class {
  constructor(t2) {
    this.Gt = t2;
  }
};
function ui(t2, e) {
  if (e.document)
    return ss(t2.Gt, e.document, !!e.hasCommittedMutations);
  if (e.noDocument) {
    const t3 = St.fromSegments(e.noDocument.path), n = wi(e.noDocument.readTime), s = Wt.newNoDocument(t3, n);
    return e.hasCommittedMutations ? s.setHasCommittedMutations() : s;
  }
  if (e.unknownDocument) {
    const t3 = St.fromSegments(e.unknownDocument.path), n = wi(e.unknownDocument.version);
    return Wt.newUnknownDocument(t3, n);
  }
  return L2();
}
function hi(t2, e, n) {
  const s = li(n), i = e.key.path.popLast().toArray();
  if (e.isFoundDocument()) {
    const n2 = function(t3, e2) {
      return {
        name: Jn(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: jn(t3, e2.version.toTimestamp())
      };
    }(t2.Gt, e), r = e.hasCommittedMutations;
    return new $s(null, null, n2, r, s, i);
  }
  if (e.isNoDocument()) {
    const t3 = e.key.path.toArray(), n2 = di(e.version), r = e.hasCommittedMutations;
    return new $s(null, new ks(t3, n2), null, r, s, i);
  }
  if (e.isUnknownDocument()) {
    const t3 = e.key.path.toArray(), n2 = di(e.version);
    return new $s(new xs(t3, n2), null, null, true, s, i);
  }
  return L2();
}
function li(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function fi(t2) {
  const e = new at(t2[0], t2[1]);
  return ct.fromTimestamp(e);
}
function di(t2) {
  const e = t2.toTimestamp();
  return new Vs(e.seconds, e.nanoseconds);
}
function wi(t2) {
  const e = new at(t2.seconds, t2.nanoseconds);
  return ct.fromTimestamp(e);
}
function _i(t2, e) {
  const n = (e.baseMutations || []).map((e2) => as(t2.Gt, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && e.mutations[t3 + 1].transform !== void 0) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => as(t2.Gt, e2)), i = at.fromMillis(e.localWriteTimeMs);
  return new ri(e.batchId, i, n, s);
}
function mi(t2) {
  const e = wi(t2.readTime), n = t2.lastLimboFreeSnapshotVersion !== void 0 ? wi(t2.lastLimboFreeSnapshotVersion) : ct.min();
  let s;
  var i;
  return t2.query.documents !== void 0 ? (B2((i = t2.query).documents.length === 1), s = Re(ge(Zn(i.documents[0])))) : s = function(t3) {
    return Re(ls(t3));
  }(t2.query), new ai(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, yt.fromBase64String(t2.resumeToken));
}
function gi(t2, e) {
  const n = di(e.snapshotVersion), s = di(e.lastLimboFreeSnapshotVersion);
  let i;
  i = Xt(e.target) ? us(t2.Gt, e.target) : hs(t2.Gt, e.target);
  const r = e.resumeToken.toBase64();
  return new Os(e.targetId, Ht(e.target), n, r, e.sequenceNumber, s, i);
}
function yi(t2) {
  const e = ls({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? Pe(e, e.limit, "L") : e;
}
var pi = class {
  getBundleMetadata(t2, e) {
    return Ti(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: wi(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return Ti(t2).put({
      bundleId: (n = e).id,
      createTime: di(Gn(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return Ei(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: yi(e2.bundledQuery),
          readTime: wi(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return Ei(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: di(Gn(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function Ti(t2) {
  return ii(t2, qs.store);
}
function Ei(t2) {
  return ii(t2, Ks.store);
}
var Ii = class {
  constructor() {
    this.zt = new Ai();
  }
  addToCollectionParentIndex(t2, e) {
    return this.zt.add(e), Gs.resolve();
  }
  getCollectionParents(t2, e) {
    return Gs.resolve(this.zt.getEntries(e));
  }
};
var Ai = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new Tn(dt.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new Tn(dt.comparator)).toArray();
  }
};
var Ri = class {
  constructor() {
    this.Ht = new Ai();
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.Ht.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.Ht.add(e);
      });
      const i = {
        collectionId: n,
        parent: Rs(s)
      };
      return Pi(t2).put(i);
    }
    return Gs.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound([e, ""], [ot(e), ""], false, true);
    return Pi(t2).Bt(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(vs(s2.parent));
      }
      return n;
    });
  }
};
function Pi(t2) {
  return ii(t2, Bs.store);
}
var bi = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var vi = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new vi(t2, vi.DEFAULT_COLLECTION_PERCENTILE, vi.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function Vi(t2, e, n) {
  const s = t2.store(Cs.store), i = t2.store(Ns.store), r = [], o = IDBKeyRange.only(n.batchId);
  let a = 0;
  const c = s.jt({
    range: o
  }, (t3, e2, n2) => (a++, n2.delete()));
  r.push(c.next(() => {
    B2(a === 1);
  }));
  const u = [];
  for (const t3 of n.mutations) {
    const s2 = Ns.key(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), u.push(t3.key);
  }
  return Gs.waitFor(r).next(() => u);
}
function Si(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw L2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
vi.DEFAULT_COLLECTION_PERCENTILE = 10, vi.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, vi.DEFAULT = new vi(41943040, vi.DEFAULT_COLLECTION_PERCENTILE, vi.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), vi.DISABLED = new vi(-1, 0, 0);
var Di = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.k = e, this.Jt = n, this.referenceDelegate = s, this.Yt = {};
  }
  static Xt(t2, e, n, s) {
    B2(t2.uid !== "");
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new Di(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return Ni(t2).jt({
      index: Cs.userMutationsIndex,
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = ki(t2), r = Ni(t2);
    return r.add({}).next((o) => {
      B2(typeof o == "number");
      const a = new ri(o, e, n, s), c = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => os(t3.Gt, e3)), i2 = n2.mutations.map((e3) => os(t3.Gt, e3));
        return new Cs(e2, n2.batchId, n2.localWriteTime.toMillis(), s2, i2);
      }(this.k, this.userId, a), u = [];
      let h = new Tn((t3, e2) => it(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = Ns.key(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), u.push(r.put(c)), u.push(i.put(e2, Ns.PLACEHOLDER));
      }
      return h.forEach((e2) => {
        u.push(this.Jt.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.Yt[o] = a.keys();
      }), Gs.waitFor(u).next(() => a);
    });
  }
  lookupMutationBatch(t2, e) {
    return Ni(t2).get(e).next((t3) => t3 ? (B2(t3.userId === this.userId), _i(this.k, t3)) : null);
  }
  Zt(t2, e) {
    return this.Yt[e] ? Gs.resolve(this.Yt[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.Yt[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return Ni(t2).jt({
      index: Cs.userMutationsIndex,
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (B2(e2.batchId >= n), i = _i(this.k, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return Ni(t2).jt({
      index: Cs.userMutationsIndex,
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return Ni(t2).Bt(Cs.userMutationsIndex, e).next((t3) => t3.map((t4) => _i(this.k, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = Ns.prefixForPath(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return ki(t2).jt({
      range: s
    }, (n2, s2, r) => {
      const [o, a, c] = n2, u = vs(a);
      if (o === this.userId && e.path.isEqual(u))
        return Ni(t2).get(c).next((t3) => {
          if (!t3)
            throw L2();
          B2(t3.userId === this.userId), i.push(_i(this.k, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new Tn(it);
    const s = [];
    return e.forEach((e2) => {
      const i = Ns.prefixForPath(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = ki(t2).jt({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, a] = t3, c = vs(o2);
        r2 === this.userId && e2.path.isEqual(c) ? n = n.add(a) : i2.done();
      });
      s.push(o);
    }), Gs.waitFor(s).next(() => this.te(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = Ns.prefixForPath(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new Tn(it);
    return ki(t2).jt({
      range: r
    }, (t3, e2, i2) => {
      const [r2, a, c] = t3, u = vs(a);
      r2 === this.userId && n.isPrefixOf(u) ? u.length === s && (o = o.add(c)) : i2.done();
    }).next(() => this.te(t2, o));
  }
  te(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(Ni(t2).get(e2).next((t3) => {
        if (t3 === null)
          throw L2();
        B2(t3.userId === this.userId), n.push(_i(this.k, t3));
      }));
    }), Gs.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return Vi(t2.Wt, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this.ee(e.batchId);
    }), Gs.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  ee(t2) {
    delete this.Yt[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return Gs.resolve();
      const n = IDBKeyRange.lowerBound(Ns.prefixForUser(this.userId)), s = [];
      return ki(t2).jt({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = vs(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        B2(s.length === 0);
      });
    });
  }
  containsKey(t2, e) {
    return Ci(t2, this.userId, e);
  }
  ne(t2) {
    return xi(t2).get(this.userId).next((t3) => t3 || new Ds(this.userId, -1, ""));
  }
};
function Ci(t2, e, n) {
  const s = Ns.prefixForPath(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return ki(t2).jt({
    range: r,
    Kt: true
  }, (t3, n2, s2) => {
    const [r2, a, c] = t3;
    r2 === e && a === i && (o = true), s2.done();
  }).next(() => o);
}
function Ni(t2) {
  return ii(t2, Cs.store);
}
function ki(t2) {
  return ii(t2, Ns.store);
}
function xi(t2) {
  return ii(t2, Ds.store);
}
var $i = class {
  constructor(t2) {
    this.se = t2;
  }
  next() {
    return this.se += 2, this.se;
  }
  static ie() {
    return new $i(0);
  }
  static re() {
    return new $i(-1);
  }
};
var Fi = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.k = e;
  }
  allocateTargetId(t2) {
    return this.oe(t2).next((e) => {
      const n = new $i(e.highestTargetId);
      return e.highestTargetId = n.next(), this.ae(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.oe(t2).next((t3) => ct.fromTimestamp(new at(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.oe(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.oe(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.ae(t2, s)));
  }
  addTargetData(t2, e) {
    return this.ce(t2, e).next(() => this.oe(t2).next((n) => (n.targetCount += 1, this.ue(e, n), this.ae(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.ce(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => Oi(t2).delete(e.targetId)).next(() => this.oe(t2)).next((e2) => (B2(e2.targetCount > 0), e2.targetCount -= 1, this.ae(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return Oi(t2).jt((r, o) => {
      const a = mi(o);
      a.sequenceNumber <= e && n.get(a.targetId) === null && (s++, i.push(this.removeTargetData(t2, a)));
    }).next(() => Gs.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return Oi(t2).jt((t3, n) => {
      const s = mi(n);
      e(s);
    });
  }
  oe(t2) {
    return Mi(t2).get(Ls.key).next((t3) => (B2(t3 !== null), t3));
  }
  ae(t2, e) {
    return Mi(t2).put(Ls.key, e);
  }
  ce(t2, e) {
    return Oi(t2).put(gi(this.k, e));
  }
  ue(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.oe(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = Ht(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return Oi(t2).jt({
      range: s,
      index: Os.queryTargetsIndexName
    }, (t3, n2, s2) => {
      const r = mi(n2);
      Yt(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = Li(t2);
    return e.forEach((e2) => {
      const r = Rs(e2.path);
      s.push(i.put(new Ms(n, r))), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), Gs.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = Li(t2);
    return Gs.forEach(e, (e2) => {
      const i = Rs(e2.path);
      return Gs.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = Li(t2), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound([e], [e + 1], false, true), s = Li(t2);
    let i = Sn();
    return s.jt({
      range: n,
      Kt: true
    }, (t3, e2, n2) => {
      const s2 = vs(t3[1]), r = new St(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = Rs(e.path), s = IDBKeyRange.bound([n], [ot(n)], false, true);
    let i = 0;
    return Li(t2).jt({
      index: Ms.documentTargetsIndex,
      Kt: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      t3 !== 0 && (i++, s2.done());
    }).next(() => i > 0);
  }
  Et(t2, e) {
    return Oi(t2).get(e).next((t3) => t3 ? mi(t3) : null);
  }
};
function Oi(t2) {
  return ii(t2, Os.store);
}
function Mi(t2) {
  return ii(t2, Ls.store);
}
function Li(t2) {
  return ii(t2, Ms.store);
}
async function Bi(t2) {
  if (t2.code !== K2.FAILED_PRECONDITION || t2.message !== Qs)
    throw t2;
  $("LocalStore", "Unexpectedly lost primary lease");
}
function Ui([t2, e], [n, s]) {
  const i = it(t2, n);
  return i === 0 ? it(e, s) : i;
}
var qi = class {
  constructor(t2) {
    this.he = t2, this.buffer = new Tn(Ui), this.le = 0;
  }
  fe() {
    return ++this.le;
  }
  de(t2) {
    const e = [t2, this.fe()];
    if (this.buffer.size < this.he)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      Ui(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var Ki = class {
  constructor(t2, e) {
    this.garbageCollector = t2, this.asyncQueue = e, this.we = false, this._e = null;
  }
  start(t2) {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.me(t2);
  }
  stop() {
    this._e && (this._e.cancel(), this._e = null);
  }
  get started() {
    return this._e !== null;
  }
  me(t2) {
    const e = this.we ? 3e5 : 6e4;
    $("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this._e = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
      this._e = null, this.we = true;
      try {
        await t2.collectGarbage(this.garbageCollector);
      } catch (t3) {
        Xs(t3) ? $("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await Bi(t3);
      }
      await this.me(t2);
    });
  }
};
var ji = class {
  constructor(t2, e) {
    this.ge = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.ge.ye(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (e === 0)
      return Gs.resolve(et.I);
    const n = new qi(e);
    return this.ge.forEachTarget(t2, (t3) => n.de(t3.sequenceNumber)).next(() => this.ge.pe(t2, (t3) => n.de(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.ge.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.ge.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? ($("LruGarbageCollector", "Garbage collection skipped; disabled"), Gs.resolve(bi)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? ($("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), bi) : this.Te(t2, e));
  }
  getCacheSize(t2) {
    return this.ge.getCacheSize(t2);
  }
  Te(t2, e) {
    let n, s, i, r, o, c, u;
    const h = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? ($("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, c = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (u = Date.now(), k2() <= LogLevel.DEBUG) {
        $("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (c - o) + `ms
	Removed ${t3} documents in ` + (u - c) + `ms
Total Duration: ${u - h}ms`);
      }
      return Gs.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var Qi = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new ji(t3, e2);
    }(this, e);
  }
  ye(t2) {
    const e = this.Ee(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  Ee(t2) {
    let e = 0;
    return this.pe(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  pe(t2, e) {
    return this.Ie(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return Wi(t2, n);
  }
  removeReference(t2, e, n) {
    return Wi(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return Wi(t2, e);
  }
  Ae(t2, e) {
    return function(t3, e2) {
      let n = false;
      return xi(t3).Qt((s) => Ci(t3, s, e2).next((t4) => (t4 && (n = true), Gs.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.Ie(t2, (r, o) => {
      if (o <= e) {
        const e2 = this.Ae(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r), Li(t2).delete([0, Rs(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => Gs.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return Wi(t2, e);
  }
  Ie(t2, e) {
    const n = Li(t2);
    let s, i = et.I;
    return n.jt({
      index: Ms.documentTargetsIndex
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      t3 === 0 ? (i !== et.I && e(new St(vs(s)), i), i = o, s = r) : i = et.I;
    }).next(() => {
      i !== et.I && e(new St(vs(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function Wi(t2, e) {
  return Li(t2).put(function(t3, e2) {
    return new Ms(0, Rs(t3.path), e2);
  }(e, t2.currentSequenceNumber));
}
var Gi = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {};
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n !== void 0) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return this.get(t2) !== void 0;
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (s !== void 0) {
      for (let n2 = 0; n2 < s.length; n2++)
        if (this.equalsFn(s[n2][0], t2))
          return void (s[n2] = [t2, e]);
      s.push([t2, e]);
    } else
      this.inner[n] = [[t2, e]];
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n === void 0)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return n.length === 1 ? delete this.inner[e] : n.splice(s, 1), true;
    return false;
  }
  forEach(t2) {
    ht(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return lt(this.inner);
  }
};
var zi = class {
  constructor() {
    this.changes = new Gi((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  getReadTime(t2) {
    const e = this.changes.get(t2);
    return e ? e.readTime : ct.min();
  }
  addEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2.key, {
      document: t2,
      readTime: e
    });
  }
  removeEntry(t2, e = null) {
    this.assertNotApplied(), this.changes.set(t2, {
      document: Wt.newInvalidDocument(t2),
      readTime: e
    });
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return n !== void 0 ? Gs.resolve(n.document) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var Hi = class {
  constructor(t2, e) {
    this.k = t2, this.Jt = e;
  }
  addEntry(t2, e, n) {
    return Xi(t2).put(Zi(e), n);
  }
  removeEntry(t2, e) {
    const n = Xi(t2), s = Zi(e);
    return n.delete(s);
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.Re(t2, n)));
  }
  getEntry(t2, e) {
    return Xi(t2).get(Zi(e)).next((t3) => this.Pe(e, t3));
  }
  be(t2, e) {
    return Xi(t2).get(Zi(e)).next((t3) => ({
      document: this.Pe(e, t3),
      size: Si(t3)
    }));
  }
  getEntries(t2, e) {
    let n = An();
    return this.ve(t2, e, (t3, e2) => {
      const s = this.Pe(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  Ve(t2, e) {
    let n = An(), s = new gn(St.comparator);
    return this.ve(t2, e, (t3, e2) => {
      const i = this.Pe(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, Si(e2));
    }).next(() => ({
      documents: n,
      Se: s
    }));
  }
  ve(t2, e, n) {
    if (e.isEmpty())
      return Gs.resolve();
    const s = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()), i = e.getIterator();
    let r = i.getNext();
    return Xi(t2).jt({
      range: s
    }, (t3, e2, s2) => {
      const o = St.fromSegments(t3);
      for (; r && St.comparator(r, o) < 0; )
        n(r, null), r = i.getNext();
      r && r.isEqual(o) && (n(r, e2), r = i.hasNext() ? i.getNext() : null), r ? s2.Lt(r.path.toArray()) : s2.done();
    }).next(() => {
      for (; r; )
        n(r, null), r = i.hasNext() ? i.getNext() : null;
    });
  }
  getDocumentsMatchingQuery(t2, e, n) {
    let s = An();
    const i = e.path.length + 1, r = {};
    if (n.isEqual(ct.min())) {
      const t3 = e.path.toArray();
      r.range = IDBKeyRange.lowerBound(t3);
    } else {
      const t3 = e.path.toArray(), s2 = li(n);
      r.range = IDBKeyRange.lowerBound([t3, s2], true), r.index = $s.collectionReadTimeIndex;
    }
    return Xi(t2).jt(r, (t3, n2, r2) => {
      if (t3.length !== i)
        return;
      const o = ui(this.k, n2);
      e.path.isPrefixOf(o.key.path) ? Se(e, o) && (s = s.insert(o.key, o)) : r2.done();
    }).next(() => s);
  }
  newChangeBuffer(t2) {
    return new Ji(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return Yi(t2).get(Fs.key).next((t3) => (B2(!!t3), t3));
  }
  Re(t2, e) {
    return Yi(t2).put(Fs.key, e);
  }
  Pe(t2, e) {
    if (e) {
      const t3 = ui(this.k, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(ct.min())))
        return t3;
    }
    return Wt.newInvalidDocument(t2);
  }
};
var Ji = class extends zi {
  constructor(t2, e) {
    super(), this.De = t2, this.trackRemovals = e, this.Ce = new Gi((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new Tn((t3, e2) => it(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.Ce.get(i);
      if (r.document.isValidDocument()) {
        const a = hi(this.De.k, r.document, this.getReadTime(i));
        s = s.add(i.path.popLast());
        const c = Si(a);
        n += c - o, e.push(this.De.addEntry(t2, i, a));
      } else if (n -= o, this.trackRemovals) {
        const n2 = hi(this.De.k, Wt.newNoDocument(i, ct.min()), this.getReadTime(i));
        e.push(this.De.addEntry(t2, i, n2));
      } else
        e.push(this.De.removeEntry(t2, i));
    }), s.forEach((n2) => {
      e.push(this.De.Jt.addToCollectionParentIndex(t2, n2));
    }), e.push(this.De.updateMetadata(t2, n)), Gs.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.De.be(t2, e).next((t3) => (this.Ce.set(e, t3.size), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.De.Ve(t2, e).next(({ documents: t3, Se: e2 }) => (e2.forEach((t4, e3) => {
      this.Ce.set(t4, e3);
    }), t3));
  }
};
function Yi(t2) {
  return ii(t2, Fs.store);
}
function Xi(t2) {
  return ii(t2, $s.store);
}
function Zi(t2) {
  return t2.path.toArray();
}
var tr = class {
  constructor(t2) {
    this.k = t2;
  }
  Nt(t2, e, n, s) {
    B2(n < s && n >= 0 && s <= 11);
    const i = new zs("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore(Ss.store);
    }(t2), function(t3) {
      t3.createObjectStore(Ds.store, {
        keyPath: Ds.keyPath
      });
      t3.createObjectStore(Cs.store, {
        keyPath: Cs.keyPath,
        autoIncrement: true
      }).createIndex(Cs.userMutationsIndex, Cs.userMutationsKeyPath, {
        unique: true
      }), t3.createObjectStore(Ns.store);
    }(t2), er(t2), function(t3) {
      t3.createObjectStore($s.store);
    }(t2));
    let r = Gs.resolve();
    return n < 3 && s >= 3 && (n !== 0 && (!function(t3) {
      t3.deleteObjectStore(Ms.store), t3.deleteObjectStore(Os.store), t3.deleteObjectStore(Ls.store);
    }(t2), er(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store(Ls.store), n2 = new Ls(0, 0, ct.min().toTimestamp(), 0);
      return e2.put(Ls.key, n2);
    }(i))), n < 4 && s >= 4 && (n !== 0 && (r = r.next(() => function(t3, e2) {
      return e2.store(Cs.store).Bt().next((n2) => {
        t3.deleteObjectStore(Cs.store);
        t3.createObjectStore(Cs.store, {
          keyPath: Cs.keyPath,
          autoIncrement: true
        }).createIndex(Cs.userMutationsIndex, Cs.userMutationsKeyPath, {
          unique: true
        });
        const s2 = e2.store(Cs.store), i2 = n2.map((t4) => s2.put(t4));
        return Gs.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(Us.store, {
          keyPath: Us.keyPath
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.Ne(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore(Fs.store);
    }(t2), this.ke(i)))), n < 7 && s >= 7 && (r = r.next(() => this.xe(i))), n < 8 && s >= 8 && (r = r.next(() => this.$e(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2), function(t3) {
        const e2 = t3.objectStore($s.store);
        e2.createIndex($s.readTimeIndex, $s.readTimeIndexPath, {
          unique: false
        }), e2.createIndex($s.collectionReadTimeIndex, $s.collectionReadTimeIndexPath, {
          unique: false
        });
      }(e);
    })), n < 10 && s >= 10 && (r = r.next(() => this.Fe(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(qs.store, {
          keyPath: qs.keyPath
        });
      }(t2), function(t3) {
        t3.createObjectStore(Ks.store, {
          keyPath: Ks.keyPath
        });
      }(t2);
    })), r;
  }
  ke(t2) {
    let e = 0;
    return t2.store($s.store).jt((t3, n) => {
      e += Si(n);
    }).next(() => {
      const n = new Fs(e);
      return t2.store(Fs.store).put(Fs.key, n);
    });
  }
  Ne(t2) {
    const e = t2.store(Ds.store), n = t2.store(Cs.store);
    return e.Bt().next((e2) => Gs.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.Bt(Cs.userMutationsIndex, s).next((n2) => Gs.forEach(n2, (n3) => {
        B2(n3.userId === e3.userId);
        const s2 = _i(this.k, n3);
        return Vi(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  xe(t2) {
    const e = t2.store(Ms.store), n = t2.store($s.store);
    return t2.store(Ls.store).get(Ls.key).next((t3) => {
      const s = [];
      return n.jt((n2, i) => {
        const r = new dt(n2), o = function(t4) {
          return [0, Rs(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? Gs.resolve() : ((n4) => e.put(new Ms(0, Rs(n4), t3.highestListenSequenceNumber)))(r)));
      }).next(() => Gs.waitFor(s));
    });
  }
  $e(t2, e) {
    t2.createObjectStore(Bs.store, {
      keyPath: Bs.keyPath
    });
    const n = e.store(Bs.store), s = new Ai(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: Rs(s2)
        });
      }
    };
    return e.store($s.store).jt({
      Kt: true
    }, (t3, e2) => {
      const n2 = new dt(t3);
      return i(n2.popLast());
    }).next(() => e.store(Ns.store).jt({
      Kt: true
    }, ([t3, e2, n2], s2) => {
      const r = vs(e2);
      return i(r.popLast());
    }));
  }
  Fe(t2) {
    const e = t2.store(Os.store);
    return e.jt((t3, n) => {
      const s = mi(n), i = gi(this.k, s);
      return e.put(i);
    });
  }
};
function er(t2) {
  t2.createObjectStore(Ms.store, {
    keyPath: Ms.keyPath
  }).createIndex(Ms.documentTargetsIndex, Ms.documentTargetsKeyPath, {
    unique: true
  });
  t2.createObjectStore(Os.store, {
    keyPath: Os.keyPath
  }).createIndex(Os.queryTargetsIndexName, Os.queryTargetsKeyPath, {
    unique: true
  }), t2.createObjectStore(Ls.store);
}
var nr = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var sr = class {
  constructor(t2, e, n, s, i, r, o, a, c, u) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.Oe = i, this.window = r, this.document = o, this.Me = c, this.Le = u, this.Be = null, this.Ue = false, this.isPrimary = false, this.networkEnabled = true, this.qe = null, this.inForeground = false, this.Ke = null, this.je = null, this.Qe = Number.NEGATIVE_INFINITY, this.We = (t3) => Promise.resolve(), !sr.bt())
      throw new j(K2.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new Qi(this, s), this.Ge = e + "main", this.k = new ci(a), this.ze = new Hs(this.Ge, 11, new tr(this.k)), this.He = new Fi(this.referenceDelegate, this.k), this.Jt = new Ri(), this.Je = function(t3, e2) {
      return new Hi(t3, e2);
    }(this.k, this.Jt), this.Ye = new pi(), this.window && this.window.localStorage ? this.Xe = this.window.localStorage : (this.Xe = null, u === false && F2("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.Ze().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new j(K2.FAILED_PRECONDITION, nr);
      return this.tn(), this.en(), this.nn(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.He.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.Be = new et(t2, this.Me);
    }).then(() => {
      this.Ue = true;
    }).catch((t2) => (this.ze && this.ze.close(), Promise.reject(t2)));
  }
  sn(t2) {
    return this.We = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.ze.xt(async (e) => {
      e.newVersion === null && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Oe.enqueueAndForget(async () => {
      this.started && await this.Ze();
    }));
  }
  Ze() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => rr(t2).put(new Us(this.clientId, Date.now(), this.networkEnabled, this.inForeground)).next(() => {
      if (this.isPrimary)
        return this.rn(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Oe.enqueueRetryable(() => this.We(false)));
        });
    }).next(() => this.on(t2)).next((e) => this.isPrimary && !e ? this.an(t2).next(() => false) : !!e && this.cn(t2).next(() => true))).catch((t2) => {
      if (Xs(t2))
        return $("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return $("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Oe.enqueueRetryable(() => this.We(t2)), this.isPrimary = t2;
    });
  }
  rn(t2) {
    return ir(t2).get(Ss.key).next((t3) => Gs.resolve(this.un(t3)));
  }
  hn(t2) {
    return rr(t2).delete(this.clientId);
  }
  async ln() {
    if (this.isPrimary && !this.fn(this.Qe, 18e5)) {
      this.Qe = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = ii(t3, Us.store);
        return e.Bt().next((t4) => {
          const n = this.dn(t4, 18e5), s = t4.filter((t5) => n.indexOf(t5) === -1);
          return Gs.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.Xe)
        for (const e of t2)
          this.Xe.removeItem(this.wn(e.clientId));
    }
  }
  nn() {
    this.je = this.Oe.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.Ze().then(() => this.ln()).then(() => this.nn()));
  }
  un(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  on(t2) {
    if (this.Le)
      return Gs.resolve(true);
    return ir(t2).get(Ss.key).next((e) => {
      if (e !== null && this.fn(e.leaseTimestampMs, 5e3) && !this._n(e.ownerId)) {
        if (this.un(e) && this.networkEnabled)
          return true;
        if (!this.un(e)) {
          if (!e.allowTabSynchronization)
            throw new j(K2.FAILED_PRECONDITION, nr);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || rr(t2).Bt().next((t3) => this.dn(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }) === void 0);
    }).next((t3) => (this.isPrimary !== t3 && $("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.Ue = false, this.mn(), this.je && (this.je.cancel(), this.je = null), this.gn(), this.yn(), await this.ze.runTransaction("shutdown", "readwrite", [Ss.store, Us.store], (t2) => {
      const e = new si(t2, et.I);
      return this.an(e).next(() => this.hn(e));
    }), this.ze.close(), this.pn();
  }
  dn(t2, e) {
    return t2.filter((t3) => this.fn(t3.updateTimeMs, e) && !this._n(t3.clientId));
  }
  Tn() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => rr(t2).Bt().next((t3) => this.dn(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.Ue;
  }
  getMutationQueue(t2) {
    return Di.Xt(t2, this.k, this.Jt, this.referenceDelegate);
  }
  getTargetCache() {
    return this.He;
  }
  getRemoteDocumentCache() {
    return this.Je;
  }
  getIndexManager() {
    return this.Jt;
  }
  getBundleCache() {
    return this.Ye;
  }
  runTransaction(t2, e, n) {
    $("IndexedDbPersistence", "Starting transaction:", t2);
    const s = e === "readonly" ? "readonly" : "readwrite";
    let i;
    return this.ze.runTransaction(t2, s, js, (s2) => (i = new si(s2, this.Be ? this.Be.next() : et.I), e === "readwrite-primary" ? this.rn(i).next((t3) => !!t3 || this.on(i)).next((e2) => {
      if (!e2)
        throw F2(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Oe.enqueueRetryable(() => this.We(false)), new j(K2.FAILED_PRECONDITION, Qs);
      return n(i);
    }).next((t3) => this.cn(i).next(() => t3)) : this.En(i).next(() => n(i)))).then((t3) => (i.raiseOnCommittedEvent(), t3));
  }
  En(t2) {
    return ir(t2).get(Ss.key).next((t3) => {
      if (t3 !== null && this.fn(t3.leaseTimestampMs, 5e3) && !this._n(t3.ownerId) && !this.un(t3) && !(this.Le || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new j(K2.FAILED_PRECONDITION, nr);
    });
  }
  cn(t2) {
    const e = new Ss(this.clientId, this.allowTabSynchronization, Date.now());
    return ir(t2).put(Ss.key, e);
  }
  static bt() {
    return Hs.bt();
  }
  an(t2) {
    const e = ir(t2);
    return e.get(Ss.key).next((t3) => this.un(t3) ? ($("IndexedDbPersistence", "Releasing primary lease."), e.delete(Ss.key)) : Gs.resolve());
  }
  fn(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || (F2(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  tn() {
    this.document !== null && typeof this.document.addEventListener == "function" && (this.Ke = () => {
      this.Oe.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this.Ze()));
    }, this.document.addEventListener("visibilitychange", this.Ke), this.inForeground = this.document.visibilityState === "visible");
  }
  gn() {
    this.Ke && (this.document.removeEventListener("visibilitychange", this.Ke), this.Ke = null);
  }
  en() {
    var t2;
    typeof ((t2 = this.window) === null || t2 === void 0 ? void 0 : t2.addEventListener) == "function" && (this.qe = () => {
      this.mn(), isSafari() && navigator.appVersion.match(/Version\/1[45]/) && this.Oe.enterRestrictedMode(true), this.Oe.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.qe));
  }
  yn() {
    this.qe && (this.window.removeEventListener("pagehide", this.qe), this.qe = null);
  }
  _n(t2) {
    var e;
    try {
      const n = ((e = this.Xe) === null || e === void 0 ? void 0 : e.getItem(this.wn(t2))) !== null;
      return $("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return F2("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  mn() {
    if (this.Xe)
      try {
        this.Xe.setItem(this.wn(this.clientId), String(Date.now()));
      } catch (t2) {
        F2("Failed to set zombie client id.", t2);
      }
  }
  pn() {
    if (this.Xe)
      try {
        this.Xe.removeItem(this.wn(this.clientId));
      } catch (t2) {
      }
  }
  wn(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function ir(t2) {
  return ii(t2, Ss.store);
}
function rr(t2) {
  return ii(t2, Us.store);
}
function or(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var ar = class {
  constructor(t2, e) {
    this.progress = t2, this.In = e;
  }
};
var cr = class {
  constructor(t2, e, n) {
    this.Je = t2, this.An = e, this.Jt = n;
  }
  Rn(t2, e) {
    return this.An.getAllMutationBatchesAffectingDocumentKey(t2, e).next((n) => this.Pn(t2, e, n));
  }
  Pn(t2, e, n) {
    return this.Je.getEntry(t2, e).next((t3) => {
      for (const e2 of n)
        e2.applyToLocalView(t3);
      return t3;
    });
  }
  bn(t2, e) {
    t2.forEach((t3, n) => {
      for (const t4 of e)
        t4.applyToLocalView(n);
    });
  }
  vn(t2, e) {
    return this.Je.getEntries(t2, e).next((e2) => this.Vn(t2, e2).next(() => e2));
  }
  Vn(t2, e) {
    return this.An.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => this.bn(e, t3));
  }
  getDocumentsMatchingQuery(t2, e, n) {
    return function(t3) {
      return St.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
    }(e) ? this.Sn(t2, e.path) : Ie(e) ? this.Dn(t2, e, n) : this.Cn(t2, e, n);
  }
  Sn(t2, e) {
    return this.Rn(t2, new St(e)).next((t3) => {
      let e2 = Pn();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  Dn(t2, e, n) {
    const s = e.collectionGroup;
    let i = Pn();
    return this.Jt.getCollectionParents(t2, s).next((r) => Gs.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new _e(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
      }(e, r2.child(s));
      return this.Cn(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  Cn(t2, e, n) {
    let s, i;
    return this.Je.getDocumentsMatchingQuery(t2, e, n).next((n2) => (s = n2, this.An.getAllMutationBatchesAffectingQuery(t2, e))).next((e2) => (i = e2, this.Nn(t2, i, s).next((t3) => {
      s = t3;
      for (const t4 of i)
        for (const e3 of t4.mutations) {
          const n2 = e3.key;
          let i2 = s.get(n2);
          i2 == null && (i2 = Wt.newInvalidDocument(n2), s = s.insert(n2, i2)), tn(e3, i2, t4.localWriteTime), i2.isFoundDocument() || (s = s.remove(n2));
        }
    }))).next(() => (s.forEach((t3, n2) => {
      Se(e, n2) || (s = s.remove(t3));
    }), s));
  }
  Nn(t2, e, n) {
    let s = Sn();
    for (const t3 of e)
      for (const e2 of t3.mutations)
        e2 instanceof on && n.get(e2.key) === null && (s = s.add(e2.key));
    let i = n;
    return this.Je.getEntries(t2, s).next((t3) => (t3.forEach((t4, e2) => {
      e2.isFoundDocument() && (i = i.insert(t4, e2));
    }), i));
  }
};
var ur = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.kn = n, this.xn = s;
  }
  static $n(t2, e) {
    let n = Sn(), s = Sn();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new ur(t2, e.fromCache, n, s);
  }
};
var hr = class {
  Fn(t2) {
    this.On = t2;
  }
  getDocumentsMatchingQuery(t2, e, n, s) {
    return function(t3) {
      return t3.filters.length === 0 && t3.limit === null && t3.startAt == null && t3.endAt == null && (t3.explicitOrderBy.length === 0 || t3.explicitOrderBy.length === 1 && t3.explicitOrderBy[0].field.isKeyField());
    }(e) || n.isEqual(ct.min()) ? this.Mn(t2, e) : this.On.vn(t2, s).next((i) => {
      const r = this.Ln(e, i);
      return (ye(e) || pe(e)) && this.Bn(e.limitType, r, s, n) ? this.Mn(t2, e) : (k2() <= LogLevel.DEBUG && $("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), Ve(e)), this.On.getDocumentsMatchingQuery(t2, e, n).next((t3) => (r.forEach((e2) => {
        t3 = t3.insert(e2.key, e2);
      }), t3)));
    });
  }
  Ln(t2, e) {
    let n = new Tn(De(t2));
    return e.forEach((e2, s) => {
      Se(t2, s) && (n = n.add(s));
    }), n;
  }
  Bn(t2, e, n, s) {
    if (n.size !== e.size)
      return true;
    const i = t2 === "F" ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Mn(t2, e) {
    return k2() <= LogLevel.DEBUG && $("QueryEngine", "Using full collection scan to execute query:", Ve(e)), this.On.getDocumentsMatchingQuery(t2, e, ct.min());
  }
};
var lr = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.Un = e, this.k = s, this.qn = new gn(it), this.Kn = new Gi((t3) => Ht(t3), Yt), this.jn = ct.min(), this.An = t2.getMutationQueue(n), this.Qn = t2.getRemoteDocumentCache(), this.He = t2.getTargetCache(), this.Wn = new cr(this.Qn, this.An, this.persistence.getIndexManager()), this.Ye = t2.getBundleCache(), this.Un.Fn(this.Wn);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.qn));
  }
};
function fr(t2, e, n, s) {
  return new lr(t2, e, n, s);
}
async function dr(t2, e) {
  const n = q2(t2);
  let s = n.An, i = n.Wn;
  const r = await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let r2;
    return n.An.getAllMutationBatches(t3).next((o) => (r2 = o, s = n.persistence.getMutationQueue(e), i = new cr(n.Qn, s, n.persistence.getIndexManager()), s.getAllMutationBatches(t3))).next((e2) => {
      const n2 = [], s2 = [];
      let o = Sn();
      for (const t4 of r2) {
        n2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        s2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return i.vn(t3, o).next((t4) => ({
        Gn: t4,
        removedBatchIds: n2,
        addedBatchIds: s2
      }));
    });
  });
  return n.An = s, n.Wn = i, n.Un.Fn(n.Wn), r;
}
function wr(t2, e) {
  const n = q2(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.Qn.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = Gs.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          B2(r2 !== null), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && s2.addEntry(e3, n2.commitVersion));
        });
      }), o.next(() => t4.An.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.An.performConsistencyCheck(t3)).next(() => n.Wn.vn(t3, s));
  });
}
function _r(t2) {
  const e = q2(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.He.getLastRemoteSnapshotVersion(t3));
}
function mr(t2, e) {
  const n = q2(t2), s = e.snapshotVersion;
  let i = n.qn;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.Qn.newChangeBuffer({
      trackRemovals: true
    });
    i = n.qn;
    const o = [];
    e.targetChanges.forEach((e2, r2) => {
      const a2 = i.get(r2);
      if (!a2)
        return;
      o.push(n.He.removeMatchingKeys(t3, e2.removedDocuments, r2).next(() => n.He.addMatchingKeys(t3, e2.addedDocuments, r2)));
      const c = e2.resumeToken;
      if (c.approximateByteSize() > 0) {
        const u = a2.withResumeToken(c, s).withSequenceNumber(t3.currentSequenceNumber);
        i = i.insert(r2, u), function(t4, e3, n2) {
          if (B2(e3.resumeToken.approximateByteSize() > 0), t4.resumeToken.approximateByteSize() === 0)
            return true;
          if (e3.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
            return true;
          return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
        }(a2, u, e2) && o.push(n.He.updateTargetData(t3, u));
      }
    });
    let a = An();
    if (e.documentUpdates.forEach((s2, i2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(gr(t3, r, e.documentUpdates, s, void 0).next((t4) => {
      a = t4;
    })), !s.isEqual(ct.min())) {
      const e2 = n.He.getLastRemoteSnapshotVersion(t3).next((e3) => n.He.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return Gs.waitFor(o).next(() => r.apply(t3)).next(() => n.Wn.Vn(t3, a)).next(() => a);
  }).then((t3) => (n.qn = i, t3));
}
function gr(t2, e, n, s, i) {
  let r = Sn();
  return n.forEach((t3) => r = r.add(t3)), e.getEntries(t2, r).next((t3) => {
    let r2 = An();
    return n.forEach((n2, o) => {
      const a = t3.get(n2), c = (i == null ? void 0 : i.get(n2)) || s;
      o.isNoDocument() && o.version.isEqual(ct.min()) ? (e.removeEntry(n2, c), r2 = r2.insert(n2, o)) : !a.isValidDocument() || o.version.compareTo(a.version) > 0 || o.version.compareTo(a.version) === 0 && a.hasPendingWrites ? (e.addEntry(o, c), r2 = r2.insert(n2, o)) : $("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", a.version, " Watch version:", o.version);
    }), r2;
  });
}
function yr(t2, e) {
  const n = q2(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n.An.getNextMutationBatchAfterBatchId(t3, e)));
}
function pr(t2, e) {
  const n = q2(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.He.getTargetData(t3, e).next((i) => i ? (s = i, Gs.resolve(s)) : n.He.allocateTargetId(t3).next((i2) => (s = new ai(e, i2, 0, t3.currentSequenceNumber), n.He.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.qn.get(t3.targetId);
    return (s === null || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.qn = n.qn.insert(t3.targetId, t3), n.Kn.set(e, t3.targetId)), t3;
  });
}
async function Tr(t2, e, n) {
  const s = q2(t2), i = s.qn.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!Xs(t3))
      throw t3;
    $("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.qn = s.qn.remove(e), s.Kn.delete(i.target);
}
function Er(t2, e, n) {
  const s = q2(t2);
  let i = ct.min(), r = Sn();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = q2(t4), i2 = s2.Kn.get(n2);
    return i2 !== void 0 ? Gs.resolve(s2.qn.get(i2)) : s2.He.getTargetData(e2, n2);
  }(s, t3, Re(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.He.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.Un.getDocumentsMatchingQuery(t3, e, n ? i : ct.min(), n ? r : Sn())).next((t4) => ({
    documents: t4,
    zn: r
  })));
}
function Ir(t2, e) {
  const n = q2(t2), s = q2(n.He), i = n.qn.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.Et(t3, e).next((t4) => t4 ? t4.target : null));
}
function Ar(t2) {
  const e = q2(t2);
  return e.persistence.runTransaction("Get new document changes", "readonly", (t3) => function(t4, e2, n) {
    const s = q2(t4);
    let i = An(), r = li(n);
    const o = Xi(e2), a = IDBKeyRange.lowerBound(r, true);
    return o.jt({
      index: $s.readTimeIndex,
      range: a
    }, (t5, e3) => {
      const n2 = ui(s.k, e3);
      i = i.insert(n2.key, n2), r = e3.readTime;
    }).next(() => ({
      In: i,
      readTime: fi(r)
    }));
  }(e.Qn, t3, e.jn)).then(({ In: t3, readTime: n }) => (e.jn = n, t3));
}
async function Rr(t2) {
  const e = q2(t2);
  return e.persistence.runTransaction("Synchronize last document change read time", "readonly", (t3) => function(t4) {
    const e2 = Xi(t4);
    let n = ct.min();
    return e2.jt({
      index: $s.readTimeIndex,
      reverse: true
    }, (t5, e3, s) => {
      e3.readTime && (n = fi(e3.readTime)), s.done();
    }).next(() => n);
  }(t3)).then((t3) => {
    e.jn = t3;
  });
}
async function Pr(t2, e, n, s) {
  const i = q2(t2);
  let r = Sn(), o = An(), a = vn();
  for (const t3 of n) {
    const n2 = e.Hn(t3.metadata.name);
    t3.document && (r = r.add(n2)), o = o.insert(n2, e.Jn(t3)), a = a.insert(n2, e.Yn(t3.metadata.readTime));
  }
  const c = i.Qn.newChangeBuffer({
    trackRemovals: true
  }), u = await pr(i, function(t3) {
    return Re(ge(dt.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => gr(t3, c, o, ct.min(), a).next((e2) => (c.apply(t3), e2)).next((e2) => i.He.removeMatchingKeysForTargetId(t3, u.targetId).next(() => i.He.addMatchingKeys(t3, r, u.targetId)).next(() => i.Wn.Vn(t3, e2)).next(() => e2)));
}
async function br(t2, e, n = Sn()) {
  const s = await pr(t2, Re(yi(e.bundledQuery))), i = q2(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = Gn(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.Ye.saveNamedQuery(t3, e);
    const o = s.withResumeToken(yt.EMPTY_BYTE_STRING, r);
    return i.qn = i.qn.insert(o.targetId, o), i.He.updateTargetData(t3, o).next(() => i.He.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.He.addMatchingKeys(t3, n, s.targetId)).next(() => i.Ye.saveNamedQuery(t3, e));
  });
}
var vr = class {
  constructor(t2) {
    this.k = t2, this.Xn = new Map(), this.Zn = new Map();
  }
  getBundleMetadata(t2, e) {
    return Gs.resolve(this.Xn.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this.Xn.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: Gn(n.createTime)
    }), Gs.resolve();
  }
  getNamedQuery(t2, e) {
    return Gs.resolve(this.Zn.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.Zn.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: yi(t3.bundledQuery),
        readTime: Gn(t3.readTime)
      };
    }(e)), Gs.resolve();
  }
};
var Vr = class {
  constructor() {
    this.ts = new Tn(Sr.es), this.ns = new Tn(Sr.ss);
  }
  isEmpty() {
    return this.ts.isEmpty();
  }
  addReference(t2, e) {
    const n = new Sr(t2, e);
    this.ts = this.ts.add(n), this.ns = this.ns.add(n);
  }
  rs(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.os(new Sr(t2, e));
  }
  cs(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  us(t2) {
    const e = new St(new dt([])), n = new Sr(e, t2), s = new Sr(e, t2 + 1), i = [];
    return this.ns.forEachInRange([n, s], (t3) => {
      this.os(t3), i.push(t3.key);
    }), i;
  }
  hs() {
    this.ts.forEach((t2) => this.os(t2));
  }
  os(t2) {
    this.ts = this.ts.delete(t2), this.ns = this.ns.delete(t2);
  }
  ls(t2) {
    const e = new St(new dt([])), n = new Sr(e, t2), s = new Sr(e, t2 + 1);
    let i = Sn();
    return this.ns.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new Sr(t2, 0), n = this.ts.firstAfterOrEqual(e);
    return n !== null && t2.isEqual(n.key);
  }
};
var Sr = class {
  constructor(t2, e) {
    this.key = t2, this.fs = e;
  }
  static es(t2, e) {
    return St.comparator(t2.key, e.key) || it(t2.fs, e.fs);
  }
  static ss(t2, e) {
    return it(t2.fs, e.fs) || St.comparator(t2.key, e.key);
  }
};
var Dr = class {
  constructor(t2, e) {
    this.Jt = t2, this.referenceDelegate = e, this.An = [], this.ds = 1, this.ws = new Tn(Sr.es);
  }
  checkEmpty(t2) {
    return Gs.resolve(this.An.length === 0);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.ds;
    this.ds++, this.An.length > 0 && this.An[this.An.length - 1];
    const r = new ri(i, e, n, s);
    this.An.push(r);
    for (const e2 of s)
      this.ws = this.ws.add(new Sr(e2.key, i)), this.Jt.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return Gs.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return Gs.resolve(this._s(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this.gs(n), i = s < 0 ? 0 : s;
    return Gs.resolve(this.An.length > i ? this.An[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return Gs.resolve(this.An.length === 0 ? -1 : this.ds - 1);
  }
  getAllMutationBatches(t2) {
    return Gs.resolve(this.An.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new Sr(e, 0), s = new Sr(e, Number.POSITIVE_INFINITY), i = [];
    return this.ws.forEachInRange([n, s], (t3) => {
      const e2 = this._s(t3.fs);
      i.push(e2);
    }), Gs.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new Tn(it);
    return e.forEach((t3) => {
      const e2 = new Sr(t3, 0), s = new Sr(t3, Number.POSITIVE_INFINITY);
      this.ws.forEachInRange([e2, s], (t4) => {
        n = n.add(t4.fs);
      });
    }), Gs.resolve(this.ys(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    St.isDocumentKey(i) || (i = i.child(""));
    const r = new Sr(new St(i), 0);
    let o = new Tn(it);
    return this.ws.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.fs)), true);
    }, r), Gs.resolve(this.ys(o));
  }
  ys(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this._s(t3);
      n !== null && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    B2(this.ps(e.batchId, "removed") === 0), this.An.shift();
    let n = this.ws;
    return Gs.forEach(e.mutations, (s) => {
      const i = new Sr(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.ws = n;
    });
  }
  ee(t2) {
  }
  containsKey(t2, e) {
    const n = new Sr(e, 0), s = this.ws.firstAfterOrEqual(n);
    return Gs.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this.An.length, Gs.resolve();
  }
  ps(t2, e) {
    return this.gs(t2);
  }
  gs(t2) {
    if (this.An.length === 0)
      return 0;
    return t2 - this.An[0].batchId;
  }
  _s(t2) {
    const e = this.gs(t2);
    if (e < 0 || e >= this.An.length)
      return null;
    return this.An[e];
  }
};
var Cr = class {
  constructor(t2, e) {
    this.Jt = t2, this.Ts = e, this.docs = new gn(St.comparator), this.size = 0;
  }
  addEntry(t2, e, n) {
    const s = e.key, i = this.docs.get(s), r = i ? i.size : 0, o = this.Ts(e);
    return this.docs = this.docs.insert(s, {
      document: e.clone(),
      size: o,
      readTime: n
    }), this.size += o - r, this.Jt.addToCollectionParentIndex(t2, s.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return Gs.resolve(n ? n.document.clone() : Wt.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = An();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.clone() : Wt.newInvalidDocument(t3));
    }), Gs.resolve(n);
  }
  getDocumentsMatchingQuery(t2, e, n) {
    let s = An();
    const i = new St(e.path.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t3, value: { document: i2, readTime: o } } = r.getNext();
      if (!e.path.isPrefixOf(t3.path))
        break;
      o.compareTo(n) <= 0 || Se(e, i2) && (s = s.insert(i2.key, i2.clone()));
    }
    return Gs.resolve(s);
  }
  Es(t2, e) {
    return Gs.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new Nr(this);
  }
  getSize(t2) {
    return Gs.resolve(this.size);
  }
};
var Nr = class extends zi {
  constructor(t2) {
    super(), this.De = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.document.isValidDocument() ? e.push(this.De.addEntry(t2, s.document, this.getReadTime(n))) : this.De.removeEntry(n);
    }), Gs.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.De.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.De.getEntries(t2, e);
  }
};
var kr = class {
  constructor(t2) {
    this.persistence = t2, this.Is = new Gi((t3) => Ht(t3), Yt), this.lastRemoteSnapshotVersion = ct.min(), this.highestTargetId = 0, this.As = 0, this.Rs = new Vr(), this.targetCount = 0, this.Ps = $i.ie();
  }
  forEachTarget(t2, e) {
    return this.Is.forEach((t3, n) => e(n)), Gs.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return Gs.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return Gs.resolve(this.As);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.Ps.next(), Gs.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.As && (this.As = e), Gs.resolve();
  }
  ce(t2) {
    this.Is.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.Ps = new $i(e), this.highestTargetId = e), t2.sequenceNumber > this.As && (this.As = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.ce(e), this.targetCount += 1, Gs.resolve();
  }
  updateTargetData(t2, e) {
    return this.ce(e), Gs.resolve();
  }
  removeTargetData(t2, e) {
    return this.Is.delete(e.target), this.Rs.us(e.targetId), this.targetCount -= 1, Gs.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.Is.forEach((r, o) => {
      o.sequenceNumber <= e && n.get(o.targetId) === null && (this.Is.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), Gs.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return Gs.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.Is.get(e) || null;
    return Gs.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this.Rs.rs(e, n), Gs.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this.Rs.cs(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), Gs.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this.Rs.us(e), Gs.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this.Rs.ls(e);
    return Gs.resolve(n);
  }
  containsKey(t2, e) {
    return Gs.resolve(this.Rs.containsKey(e));
  }
};
var xr = class {
  constructor(t2, e) {
    this.bs = {}, this.Be = new et(0), this.Ue = false, this.Ue = true, this.referenceDelegate = t2(this), this.He = new kr(this);
    this.Jt = new Ii(), this.Je = function(t3, e2) {
      return new Cr(t3, e2);
    }(this.Jt, (t3) => this.referenceDelegate.vs(t3)), this.k = new ci(e), this.Ye = new vr(this.k);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.Ue = false, Promise.resolve();
  }
  get started() {
    return this.Ue;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager() {
    return this.Jt;
  }
  getMutationQueue(t2) {
    let e = this.bs[t2.toKey()];
    return e || (e = new Dr(this.Jt, this.referenceDelegate), this.bs[t2.toKey()] = e), e;
  }
  getTargetCache() {
    return this.He;
  }
  getRemoteDocumentCache() {
    return this.Je;
  }
  getBundleCache() {
    return this.Ye;
  }
  runTransaction(t2, e, n) {
    $("MemoryPersistence", "Starting transaction:", t2);
    const s = new $r(this.Be.next());
    return this.referenceDelegate.Vs(), n(s).next((t3) => this.referenceDelegate.Ss(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Ds(t2, e) {
    return Gs.or(Object.values(this.bs).map((n) => () => n.containsKey(t2, e)));
  }
};
var $r = class extends Ws {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var Fr = class {
  constructor(t2) {
    this.persistence = t2, this.Cs = new Vr(), this.Ns = null;
  }
  static ks(t2) {
    return new Fr(t2);
  }
  get xs() {
    if (this.Ns)
      return this.Ns;
    throw L2();
  }
  addReference(t2, e, n) {
    return this.Cs.addReference(n, e), this.xs.delete(n.toString()), Gs.resolve();
  }
  removeReference(t2, e, n) {
    return this.Cs.removeReference(n, e), this.xs.add(n.toString()), Gs.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.xs.add(e.toString()), Gs.resolve();
  }
  removeTarget(t2, e) {
    this.Cs.us(e.targetId).forEach((t3) => this.xs.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.xs.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  Vs() {
    this.Ns = new Set();
  }
  Ss(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return Gs.forEach(this.xs, (n) => {
      const s = St.fromPath(n);
      return this.$s(t2, s).next((t3) => {
        t3 || e.removeEntry(s);
      });
    }).next(() => (this.Ns = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.$s(t2, e).next((t3) => {
      t3 ? this.xs.delete(e.toString()) : this.xs.add(e.toString());
    });
  }
  vs(t2) {
    return 0;
  }
  $s(t2, e) {
    return Gs.or([() => Gs.resolve(this.Cs.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Ds(t2, e)]);
  }
};
function Or(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function Mr(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function Lr(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var Br = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static Fs(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = typeof s == "object" && ["pending", "acknowledged", "rejected"].indexOf(s.state) !== -1 && (s.error === void 0 || typeof s.error == "object");
    return r && s.error && (r = typeof s.error.message == "string" && typeof s.error.code == "string", r && (i = new j(s.error.code, s.error.message))), r ? new Br(t2, e, s.state, i) : (F2("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Os() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Ur = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static Fs(t2, e) {
    const n = JSON.parse(e);
    let s, i = typeof n == "object" && ["not-current", "current", "rejected"].indexOf(n.state) !== -1 && (n.error === void 0 || typeof n.error == "object");
    return i && n.error && (i = typeof n.error.message == "string" && typeof n.error.code == "string", i && (s = new j(n.error.code, n.error.message))), i ? new Ur(t2, n.state, s) : (F2("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Os() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var qr = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static Fs(t2, e) {
    const n = JSON.parse(e);
    let s = typeof n == "object" && n.activeTargetIds instanceof Array, i = Cn();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = Vt(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new qr(t2, i) : (F2("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var Kr = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static Fs(t2) {
    const e = JSON.parse(t2);
    return typeof e == "object" && ["Unknown", "Online", "Offline"].indexOf(e.onlineState) !== -1 && typeof e.clientId == "string" ? new Kr(e.clientId, e.onlineState) : (F2("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var jr = class {
  constructor() {
    this.activeTargetIds = Cn();
  }
  Ms(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  Ls(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Os() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var Qr = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.Oe = e, this.persistenceKey = n, this.Bs = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.Us = this.qs.bind(this), this.Ks = new gn(it), this.started = false, this.js = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.Qs = Or(this.persistenceKey, this.Bs), this.Ws = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.Ks = this.Ks.insert(this.Bs, new jr()), this.Gs = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.zs = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.Hs = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.Js = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this.Ys = function(t3) {
      return `firestore_bundle_loaded_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.Us);
  }
  static bt(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.Tn();
    for (const e2 of t2) {
      if (e2 === this.Bs)
        continue;
      const t3 = this.getItem(Or(this.persistenceKey, e2));
      if (t3) {
        const n = qr.Fs(e2, t3);
        n && (this.Ks = this.Ks.insert(n.clientId, n));
      }
    }
    this.Xs();
    const e = this.storage.getItem(this.Js);
    if (e) {
      const t3 = this.Zs(e);
      t3 && this.ti(t3);
    }
    for (const t3 of this.js)
      this.qs(t3);
    this.js = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.Ws, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.ei(this.Ks);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.Ks.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.ni(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.ni(t2, e, n), this.si(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem(Lr(this.persistenceKey, t2));
      if (n) {
        const s = Ur.Fs(t2, n);
        s && (e = s.state);
      }
    }
    return this.ii.Ms(t2), this.Xs(), e;
  }
  removeLocalQueryTarget(t2) {
    this.ii.Ls(t2), this.Xs();
  }
  isLocalQueryTarget(t2) {
    return this.ii.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(Lr(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.ri(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.si(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.oi(t2);
  }
  notifyBundleLoaded() {
    this.ai();
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.Us), this.removeItem(this.Qs), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return $("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    $("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    $("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  qs(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if ($("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.Qs)
        return void F2("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Oe.enqueueRetryable(async () => {
        if (this.started) {
          if (e.key !== null) {
            if (this.Gs.test(e.key)) {
              if (e.newValue == null) {
                const t3 = this.ci(e.key);
                return this.ui(t3, null);
              }
              {
                const t3 = this.hi(e.key, e.newValue);
                if (t3)
                  return this.ui(t3.clientId, t3);
              }
            } else if (this.zs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.li(e.key, e.newValue);
                if (t3)
                  return this.fi(t3);
              }
            } else if (this.Hs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.di(e.key, e.newValue);
                if (t3)
                  return this.wi(t3);
              }
            } else if (e.key === this.Js) {
              if (e.newValue !== null) {
                const t3 = this.Zs(e.newValue);
                if (t3)
                  return this.ti(t3);
              }
            } else if (e.key === this.Ws) {
              const t3 = function(t4) {
                let e2 = et.I;
                if (t4 != null)
                  try {
                    const n = JSON.parse(t4);
                    B2(typeof n == "number"), e2 = n;
                  } catch (t5) {
                    F2("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== et.I && this.sequenceNumberHandler(t3);
            } else if (e.key === this.Ys)
              return this.syncEngine._i();
          }
        } else
          this.js.push(e);
      });
    }
  }
  get ii() {
    return this.Ks.get(this.Bs);
  }
  Xs() {
    this.setItem(this.Qs, this.ii.Os());
  }
  ni(t2, e, n) {
    const s = new Br(this.currentUser, t2, e, n), i = Mr(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Os());
  }
  si(t2) {
    const e = Mr(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  oi(t2) {
    const e = {
      clientId: this.Bs,
      onlineState: t2
    };
    this.storage.setItem(this.Js, JSON.stringify(e));
  }
  ri(t2, e, n) {
    const s = Lr(this.persistenceKey, t2), i = new Ur(t2, e, n);
    this.setItem(s, i.Os());
  }
  ai() {
    this.setItem(this.Ys, "value-not-used");
  }
  ci(t2) {
    const e = this.Gs.exec(t2);
    return e ? e[1] : null;
  }
  hi(t2, e) {
    const n = this.ci(t2);
    return qr.Fs(n, e);
  }
  li(t2, e) {
    const n = this.zs.exec(t2), s = Number(n[1]), i = n[2] !== void 0 ? n[2] : null;
    return Br.Fs(new D2(i), s, e);
  }
  di(t2, e) {
    const n = this.Hs.exec(t2), s = Number(n[1]);
    return Ur.Fs(s, e);
  }
  Zs(t2) {
    return Kr.Fs(t2);
  }
  async fi(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine.mi(t2.batchId, t2.state, t2.error);
    $("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  wi(t2) {
    return this.syncEngine.gi(t2.targetId, t2.state, t2.error);
  }
  ui(t2, e) {
    const n = e ? this.Ks.insert(t2, e) : this.Ks.remove(t2), s = this.ei(this.Ks), i = this.ei(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.yi(r, o).then(() => {
      this.Ks = n;
    });
  }
  ti(t2) {
    this.Ks.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  ei(t2) {
    let e = Cn();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var Wr = class {
  constructor() {
    this.pi = new jr(), this.Ti = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this.pi.Ms(t2), this.Ti[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.Ti[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.pi.Ls(t2);
  }
  isLocalQueryTarget(t2) {
    return this.pi.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.Ti[t2];
  }
  getAllActiveQueryTargets() {
    return this.pi.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.pi.activeTargetIds.has(t2);
  }
  start() {
    return this.pi = new jr(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded() {
  }
};
var Gr = class {
  Ei(t2) {
  }
  shutdown() {
  }
};
var zr = class {
  constructor() {
    this.Ii = () => this.Ai(), this.Ri = () => this.Pi(), this.bi = [], this.vi();
  }
  Ei(t2) {
    this.bi.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.Ii), window.removeEventListener("offline", this.Ri);
  }
  vi() {
    window.addEventListener("online", this.Ii), window.addEventListener("offline", this.Ri);
  }
  Ai() {
    $("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.bi)
      t2(0);
  }
  Pi() {
    $("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.bi)
      t2(1);
  }
  static bt() {
    return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
};
var Hr = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var Jr = class {
  constructor(t2) {
    this.Vi = t2.Vi, this.Si = t2.Si;
  }
  Di(t2) {
    this.Ci = t2;
  }
  Ni(t2) {
    this.ki = t2;
  }
  onMessage(t2) {
    this.xi = t2;
  }
  close() {
    this.Si();
  }
  send(t2) {
    this.Vi(t2);
  }
  $i() {
    this.Ci();
  }
  Fi(t2) {
    this.ki(t2);
  }
  Oi(t2) {
    this.xi(t2);
  }
};
var Yr = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.Mi = e + "://" + t2.host, this.Li = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  Bi(t2, e, n, s, i) {
    const r = this.Ui(t2, e);
    $("RestConnection", "Sending: ", r, n);
    const o = {};
    return this.qi(o, s, i), this.Ki(t2, r, o, n).then((t3) => ($("RestConnection", "Received: ", t3), t3), (e2) => {
      throw O2("RestConnection", `${t2} failed with error: `, e2, "url: ", r, "request:", n), e2;
    });
  }
  ji(t2, e, n, s, i) {
    return this.Bi(t2, e, n, s, i);
  }
  qi(t2, e, n) {
    t2["X-Goog-Api-Client"] = "gl-js/ fire/" + C2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e && e.headers.forEach((e2, n2) => t2[n2] = e2), n && n.headers.forEach((e2, n2) => t2[n2] = e2);
  }
  Ui(t2, e) {
    const n = Hr[t2];
    return `${this.Mi}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  Ki(t2, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              $("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              $("Connection", 'RPC "' + t2 + '" timed out'), r(new j(K2.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if ($("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(K2).indexOf(e4) >= 0 ? e4 : K2.UNKNOWN;
                  }(t3.status);
                  r(new j(e3, t3.message));
                } else
                  r(new j(K2.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new j(K2.UNAVAILABLE, "Connection failed."));
              break;
            default:
              L2();
          }
        } finally {
          $("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const a = JSON.stringify(s);
      o.send(e, "POST", a, n, 15);
    });
  }
  Qi(t2, e, n) {
    const s = [this.Mi, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], i = createWebChannelTransport(), r = getStatEventTarget(), o = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (o.xmlHttpFactory = new FetchXmlHttpFactory({})), this.qi(o.initMessageHeaders, e, n), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (o.httpHeadersOverwriteParam = "$httpHeaders");
    const a = s.join("");
    $("Connection", "Creating WebChannel: " + a, o);
    const c = i.createWebChannel(a, o);
    let u = false, h = false;
    const g = new Jr({
      Vi: (t3) => {
        h ? $("Connection", "Not sending because WebChannel is closed:", t3) : (u || ($("Connection", "Opening WebChannel transport."), c.open(), u = true), $("Connection", "WebChannel sending:", t3), c.send(t3));
      },
      Si: () => c.close()
    }), y2 = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return y2(c, WebChannel.EventType.OPEN, () => {
      h || $("Connection", "WebChannel transport opened.");
    }), y2(c, WebChannel.EventType.CLOSE, () => {
      h || (h = true, $("Connection", "WebChannel transport closed"), g.Fi());
    }), y2(c, WebChannel.EventType.ERROR, (t3) => {
      h || (h = true, O2("Connection", "WebChannel transport errored:", t3), g.Fi(new j(K2.UNAVAILABLE, "The operation could not be completed")));
    }), y2(c, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!h) {
        const n2 = t3.data[0];
        B2(!!n2);
        const s2 = n2, i2 = s2.error || ((e2 = s2[0]) === null || e2 === void 0 ? void 0 : e2.error);
        if (i2) {
          $("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = dn[t5];
            if (e4 !== void 0)
              return mn(e4);
          }(t4), n3 = i2.message;
          e3 === void 0 && (e3 = K2.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), h = true, g.Fi(new j(e3, n3)), c.close();
        } else
          $("Connection", "WebChannel received:", n2), g.Oi(n2);
      }
    }), y2(r, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? $("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && $("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      g.$i();
    }, 0), g;
  }
};
function Xr() {
  return typeof window != "undefined" ? window : null;
}
function Zr() {
  return typeof document != "undefined" ? document : null;
}
function to(t2) {
  return new Kn(t2, true);
}
var eo = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.Oe = t2, this.timerId = e, this.Wi = n, this.Gi = s, this.zi = i, this.Hi = 0, this.Ji = null, this.Yi = Date.now(), this.reset();
  }
  reset() {
    this.Hi = 0;
  }
  Xi() {
    this.Hi = this.zi;
  }
  Zi(t2) {
    this.cancel();
    const e = Math.floor(this.Hi + this.tr()), n = Math.max(0, Date.now() - this.Yi), s = Math.max(0, e - n);
    s > 0 && $("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.Hi} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.Ji = this.Oe.enqueueAfterDelay(this.timerId, s, () => (this.Yi = Date.now(), t2())), this.Hi *= this.Gi, this.Hi < this.Wi && (this.Hi = this.Wi), this.Hi > this.zi && (this.Hi = this.zi);
  }
  er() {
    this.Ji !== null && (this.Ji.skipDelay(), this.Ji = null);
  }
  cancel() {
    this.Ji !== null && (this.Ji.cancel(), this.Ji = null);
  }
  tr() {
    return (Math.random() - 0.5) * this.Hi;
  }
};
var no = class {
  constructor(t2, e, n, s, i, r, o, a) {
    this.Oe = t2, this.nr = n, this.sr = s, this.ir = i, this.authCredentialsProvider = r, this.appCheckCredentialsProvider = o, this.listener = a, this.state = 0, this.rr = 0, this.ar = null, this.cr = null, this.stream = null, this.ur = new eo(t2, e);
  }
  hr() {
    return this.state === 1 || this.state === 5 || this.lr();
  }
  lr() {
    return this.state === 2 || this.state === 3;
  }
  start() {
    this.state !== 4 ? this.auth() : this.dr();
  }
  async stop() {
    this.hr() && await this.close(0);
  }
  wr() {
    this.state = 0, this.ur.reset();
  }
  _r() {
    this.lr() && this.ar === null && (this.ar = this.Oe.enqueueAfterDelay(this.nr, 6e4, () => this.mr()));
  }
  gr(t2) {
    this.yr(), this.stream.send(t2);
  }
  async mr() {
    if (this.lr())
      return this.close(0);
  }
  yr() {
    this.ar && (this.ar.cancel(), this.ar = null);
  }
  pr() {
    this.cr && (this.cr.cancel(), this.cr = null);
  }
  async close(t2, e) {
    this.yr(), this.pr(), this.ur.cancel(), this.rr++, t2 !== 4 ? this.ur.reset() : e && e.code === K2.RESOURCE_EXHAUSTED ? (F2(e.toString()), F2("Using maximum backoff delay to prevent overloading the backend."), this.ur.Xi()) : e && e.code === K2.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), this.stream !== null && (this.Tr(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Ni(e);
  }
  Tr() {
  }
  auth() {
    this.state = 1;
    const t2 = this.Er(this.rr), e = this.rr;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t3, n]) => {
      this.rr === e && this.Ir(t3, n);
    }, (e2) => {
      t2(() => {
        const t3 = new j(K2.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.Ar(t3);
      });
    });
  }
  Ir(t2, e) {
    const n = this.Er(this.rr);
    this.stream = this.Rr(t2, e), this.stream.Di(() => {
      n(() => (this.state = 2, this.cr = this.Oe.enqueueAfterDelay(this.sr, 1e4, () => (this.lr() && (this.state = 3), Promise.resolve())), this.listener.Di()));
    }), this.stream.Ni((t3) => {
      n(() => this.Ar(t3));
    }), this.stream.onMessage((t3) => {
      n(() => this.onMessage(t3));
    });
  }
  dr() {
    this.state = 5, this.ur.Zi(async () => {
      this.state = 0, this.start();
    });
  }
  Ar(t2) {
    return $("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(4, t2);
  }
  Er(t2) {
    return (e) => {
      this.Oe.enqueueAndForget(() => this.rr === t2 ? e() : ($("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var so = class extends no {
  constructor(t2, e, n, s, i, r) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e, n, s, r), this.k = i;
  }
  Rr(t2, e) {
    return this.ir.Qi("Listen", t2, e);
  }
  onMessage(t2) {
    this.ur.reset();
    const e = rs(this.k, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return ct.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? ct.min() : e2.readTime ? Gn(e2.readTime) : ct.min();
    }(t2);
    return this.listener.Pr(e, n);
  }
  br(t2) {
    const e = {};
    e.database = ts(this.k), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = Xt(s) ? {
        documents: us(t3, s)
      } : {
        query: hs(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = Qn(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(ct.min()) > 0 && (n2.readTime = jn(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.k, t2);
    const n = fs(this.k, t2);
    n && (e.labels = n), this.gr(e);
  }
  vr(t2) {
    const e = {};
    e.database = ts(this.k), e.removeTarget = t2, this.gr(e);
  }
};
var io = class extends no {
  constructor(t2, e, n, s, i, r) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, n, s, r), this.k = i, this.Vr = false;
  }
  get Sr() {
    return this.Vr;
  }
  start() {
    this.Vr = false, this.lastStreamToken = void 0, super.start();
  }
  Tr() {
    this.Vr && this.Dr([]);
  }
  Rr(t2, e) {
    return this.ir.Qi("Write", t2, e);
  }
  onMessage(t2) {
    if (B2(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.Vr) {
      this.ur.reset();
      const e = cs(t2.writeResults, t2.commitTime), n = Gn(t2.commitTime);
      return this.listener.Cr(n, e);
    }
    return B2(!t2.writeResults || t2.writeResults.length === 0), this.Vr = true, this.listener.Nr();
  }
  kr() {
    const t2 = {};
    t2.database = ts(this.k), this.gr(t2);
  }
  Dr(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => os(this.k, t3))
    };
    this.gr(e);
  }
};
var ro = class extends class {
} {
  constructor(t2, e, n, s) {
    super(), this.authCredentials = t2, this.appCheckCredentials = e, this.ir = n, this.k = s, this.$r = false;
  }
  Fr() {
    if (this.$r)
      throw new j(K2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  Bi(t2, e, n) {
    return this.Fr(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.ir.Bi(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === K2.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new j(K2.UNKNOWN, t3.toString());
    });
  }
  ji(t2, e, n) {
    return this.Fr(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.ir.ji(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === K2.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new j(K2.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.$r = true;
  }
};
var oo = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.Or = 0, this.Mr = null, this.Lr = true;
  }
  Br() {
    this.Or === 0 && (this.Ur("Unknown"), this.Mr = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.Mr = null, this.qr("Backend didn't respond within 10 seconds."), this.Ur("Offline"), Promise.resolve())));
  }
  Kr(t2) {
    this.state === "Online" ? this.Ur("Unknown") : (this.Or++, this.Or >= 1 && (this.jr(), this.qr(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.Ur("Offline")));
  }
  set(t2) {
    this.jr(), this.Or = 0, t2 === "Online" && (this.Lr = false), this.Ur(t2);
  }
  Ur(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  qr(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.Lr ? (F2(e), this.Lr = false) : $("OnlineStateTracker", e);
  }
  jr() {
    this.Mr !== null && (this.Mr.cancel(), this.Mr = null);
  }
};
var ao = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.Qr = [], this.Wr = new Map(), this.Gr = new Set(), this.zr = [], this.Hr = i, this.Hr.Ei((t3) => {
      n.enqueueAndForget(async () => {
        go(this) && ($("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = q2(t4);
          e2.Gr.add(4), await uo(e2), e2.Jr.set("Unknown"), e2.Gr.delete(4), await co(e2);
        }(this));
      });
    }), this.Jr = new oo(n, s);
  }
};
async function co(t2) {
  if (go(t2))
    for (const e of t2.zr)
      await e(true);
}
async function uo(t2) {
  for (const e of t2.zr)
    await e(false);
}
function ho(t2, e) {
  const n = q2(t2);
  n.Wr.has(e.targetId) || (n.Wr.set(e.targetId, e), mo(n) ? _o(n) : xo(n).lr() && fo(n, e));
}
function lo(t2, e) {
  const n = q2(t2), s = xo(n);
  n.Wr.delete(e), s.lr() && wo(n, e), n.Wr.size === 0 && (s.lr() ? s._r() : go(n) && n.Jr.set("Unknown"));
}
function fo(t2, e) {
  t2.Yr.X(e.targetId), xo(t2).br(e);
}
function wo(t2, e) {
  t2.Yr.X(e), xo(t2).vr(e);
}
function _o(t2) {
  t2.Yr = new Mn({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    Et: (e) => t2.Wr.get(e) || null
  }), xo(t2).start(), t2.Jr.Br();
}
function mo(t2) {
  return go(t2) && !xo(t2).hr() && t2.Wr.size > 0;
}
function go(t2) {
  return q2(t2).Gr.size === 0;
}
function yo(t2) {
  t2.Yr = void 0;
}
async function po(t2) {
  t2.Wr.forEach((e, n) => {
    fo(t2, e);
  });
}
async function To(t2, e) {
  yo(t2), mo(t2) ? (t2.Jr.Kr(e), _o(t2)) : t2.Jr.set("Unknown");
}
async function Eo(t2, e, n) {
  if (t2.Jr.set("Online"), e instanceof Fn && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.Wr.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.Wr.delete(s), t3.Yr.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      $("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await Io(t2, n2);
    }
  else if (e instanceof xn ? t2.Yr.ot(e) : e instanceof $n ? t2.Yr.dt(e) : t2.Yr.ut(e), !n.isEqual(ct.min()))
    try {
      const e2 = await _r(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.Yr.gt(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.Wr.get(s);
            i && t3.Wr.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.Wr.get(e4);
          if (!n3)
            return;
          t3.Wr.set(e4, n3.withResumeToken(yt.EMPTY_BYTE_STRING, n3.snapshotVersion)), wo(t3, e4);
          const s = new ai(n3.target, e4, 1, n3.sequenceNumber);
          fo(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      $("RemoteStore", "Failed to raise snapshot:", e2), await Io(t2, e2);
    }
}
async function Io(t2, e, n) {
  if (!Xs(e))
    throw e;
  t2.Gr.add(1), await uo(t2), t2.Jr.set("Offline"), n || (n = () => _r(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    $("RemoteStore", "Retrying IndexedDB access"), await n(), t2.Gr.delete(1), await co(t2);
  });
}
function Ao(t2, e) {
  return e().catch((n) => Io(t2, n, e));
}
async function Ro(t2) {
  const e = q2(t2), n = $o(e);
  let s = e.Qr.length > 0 ? e.Qr[e.Qr.length - 1].batchId : -1;
  for (; Po(e); )
    try {
      const t3 = await yr(e.localStore, s);
      if (t3 === null) {
        e.Qr.length === 0 && n._r();
        break;
      }
      s = t3.batchId, bo(e, t3);
    } catch (t3) {
      await Io(e, t3);
    }
  vo(e) && Vo(e);
}
function Po(t2) {
  return go(t2) && t2.Qr.length < 10;
}
function bo(t2, e) {
  t2.Qr.push(e);
  const n = $o(t2);
  n.lr() && n.Sr && n.Dr(e.mutations);
}
function vo(t2) {
  return go(t2) && !$o(t2).hr() && t2.Qr.length > 0;
}
function Vo(t2) {
  $o(t2).start();
}
async function So(t2) {
  $o(t2).kr();
}
async function Do(t2) {
  const e = $o(t2);
  for (const n of t2.Qr)
    e.Dr(n.mutations);
}
async function Co(t2, e, n) {
  const s = t2.Qr.shift(), i = oi.from(s, e, n);
  await Ao(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await Ro(t2);
}
async function No(t2, e) {
  e && $o(t2).Sr && await async function(t3, e2) {
    if (n = e2.code, _n(n) && n !== K2.ABORTED) {
      const n2 = t3.Qr.shift();
      $o(t3).wr(), await Ao(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await Ro(t3);
    }
    var n;
  }(t2, e), vo(t2) && Vo(t2);
}
async function ko(t2, e) {
  const n = q2(t2);
  e ? (n.Gr.delete(2), await co(n)) : e || (n.Gr.add(2), await uo(n), n.Jr.set("Unknown"));
}
function xo(t2) {
  return t2.Xr || (t2.Xr = function(t3, e, n) {
    const s = q2(t3);
    return s.Fr(), new so(e, s.ir, s.authCredentials, s.appCheckCredentials, s.k, n);
  }(t2.datastore, t2.asyncQueue, {
    Di: po.bind(null, t2),
    Ni: To.bind(null, t2),
    Pr: Eo.bind(null, t2)
  }), t2.zr.push(async (e) => {
    e ? (t2.Xr.wr(), mo(t2) ? _o(t2) : t2.Jr.set("Unknown")) : (await t2.Xr.stop(), yo(t2));
  })), t2.Xr;
}
function $o(t2) {
  return t2.Zr || (t2.Zr = function(t3, e, n) {
    const s = q2(t3);
    return s.Fr(), new io(e, s.ir, s.authCredentials, s.appCheckCredentials, s.k, n);
  }(t2.datastore, t2.asyncQueue, {
    Di: So.bind(null, t2),
    Ni: No.bind(null, t2),
    Nr: Do.bind(null, t2),
    Cr: Co.bind(null, t2)
  }), t2.zr.push(async (e) => {
    e ? (t2.Zr.wr(), await Ro(t2)) : (await t2.Zr.stop(), t2.Qr.length > 0 && ($("RemoteStore", `Stopping write stream with ${t2.Qr.length} pending writes`), t2.Qr = []));
  })), t2.Zr;
}
var Fo = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new Q2(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new Fo(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new j(K2.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function Oo(t2, e) {
  if (F2("AsyncQueue", `${e}: ${t2}`), Xs(t2))
    return new j(K2.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var Mo = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || St.comparator(e.key, n.key) : (t3, e) => St.comparator(t3.key, e.key), this.keyedMap = Pn(), this.sortedSet = new gn(this.comparator);
  }
  static emptySet(t2) {
    return new Mo(t2.comparator);
  }
  has(t2) {
    return this.keyedMap.get(t2) != null;
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof Mo))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new Mo();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var Lo = class {
  constructor() {
    this.eo = new gn(St.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.eo.get(e);
    n ? t2.type !== 0 && n.type === 3 ? this.eo = this.eo.insert(e, t2) : t2.type === 3 && n.type !== 1 ? this.eo = this.eo.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 2 ? this.eo = this.eo.insert(e, {
      type: 2,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 0 ? this.eo = this.eo.insert(e, {
      type: 0,
      doc: t2.doc
    }) : t2.type === 1 && n.type === 0 ? this.eo = this.eo.remove(e) : t2.type === 1 && n.type === 2 ? this.eo = this.eo.insert(e, {
      type: 1,
      doc: n.doc
    }) : t2.type === 0 && n.type === 1 ? this.eo = this.eo.insert(e, {
      type: 2,
      doc: t2.doc
    }) : L2() : this.eo = this.eo.insert(e, t2);
  }
  no() {
    const t2 = [];
    return this.eo.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var Bo = class {
  constructor(t2, e, n, s, i, r, o, a) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = a;
  }
  static fromInitialDocuments(t2, e, n, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new Bo(t2, e, Mo.emptySet(e), i, n, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && be(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var Uo = class {
  constructor() {
    this.so = void 0, this.listeners = [];
  }
};
var qo = class {
  constructor() {
    this.queries = new Gi((t2) => ve(t2), be), this.onlineState = "Unknown", this.io = new Set();
  }
};
async function Ko(t2, e) {
  const n = q2(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new Uo()), i)
    try {
      r.so = await n.onListen(s);
    } catch (t3) {
      const n2 = Oo(t3, `Initialization of query '${Ve(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.ro(n.onlineState), r.so) {
    e.oo(r.so) && Go(n);
  }
}
async function jo(t2, e) {
  const n = q2(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = r.listeners.length === 0);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function Qo(t2, e) {
  const n = q2(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.oo(t3) && (s = true);
      i.so = t3;
    }
  }
  s && Go(n);
}
function Wo(t2, e, n) {
  const s = q2(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function Go(t2) {
  t2.io.forEach((t3) => {
    t3.next();
  });
}
var zo = class {
  constructor(t2, e, n) {
    this.query = t2, this.ao = e, this.co = false, this.uo = null, this.onlineState = "Unknown", this.options = n || {};
  }
  oo(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        n.type !== 3 && e2.push(n);
      t2 = new Bo(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
    }
    let e = false;
    return this.co ? this.ho(t2) && (this.ao.next(t2), e = true) : this.lo(t2, this.onlineState) && (this.fo(t2), e = true), this.uo = t2, e;
  }
  onError(t2) {
    this.ao.error(t2);
  }
  ro(t2) {
    this.onlineState = t2;
    let e = false;
    return this.uo && !this.co && this.lo(this.uo, t2) && (this.fo(this.uo), e = true), e;
  }
  lo(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = e !== "Offline";
    return (!this.options.wo || !n) && (!t2.docs.isEmpty() || e === "Offline");
  }
  ho(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.uo && this.uo.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
  }
  fo(t2) {
    t2 = Bo.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.co = true, this.ao.next(t2);
  }
};
var Ho = class {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  _o() {
    return "metadata" in this.payload;
  }
};
var Jo = class {
  constructor(t2) {
    this.k = t2;
  }
  Hn(t2) {
    return Yn(this.k, t2);
  }
  Jn(t2) {
    return t2.metadata.exists ? ss(this.k, t2.document, false) : Wt.newNoDocument(this.Hn(t2.metadata.name), this.Yn(t2.metadata.readTime));
  }
  Yn(t2) {
    return Gn(t2);
  }
};
var Yo = class {
  constructor(t2, e, n) {
    this.mo = t2, this.localStore = e, this.k = n, this.queries = [], this.documents = [], this.progress = Xo(t2);
  }
  yo(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    return t2.payload.namedQuery ? this.queries.push(t2.payload.namedQuery) : t2.payload.documentMetadata ? (this.documents.push({
      metadata: t2.payload.documentMetadata
    }), t2.payload.documentMetadata.exists || ++e) : t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e), e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  po(t2) {
    const e = new Map(), n = new Jo(this.k);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.Hn(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || Sn()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await Pr(this.localStore, new Jo(this.k), this.documents, this.mo.id), e = this.po(this.documents);
    for (const t3 of this.queries)
      await br(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", new ar(Object.assign({}, this.progress), t2);
  }
};
function Xo(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var Zo = class {
  constructor(t2) {
    this.key = t2;
  }
};
var ta2 = class {
  constructor(t2) {
    this.key = t2;
  }
};
var ea2 = class {
  constructor(t2, e) {
    this.query = t2, this.To = e, this.Eo = null, this.current = false, this.Io = Sn(), this.mutatedKeys = Sn(), this.Ao = De(t2), this.Ro = new Mo(this.Ao);
  }
  get Po() {
    return this.To;
  }
  bo(t2, e) {
    const n = e ? e.vo : new Lo(), s = e ? e.Ro : this.Ro;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const a = ye(this.query) && s.size === this.query.limit ? s.last() : null, c = pe(this.query) && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const u = s.get(t3), h = Se(this.query, e2) ? e2 : null, l2 = !!u && this.mutatedKeys.has(u.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (u && h) {
        u.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.Vo(u, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (a && this.Ao(h, a) > 0 || c && this.Ao(h, c) < 0) && (o = true));
      } else
        !u && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : u && !h && (n.track({
          type: 1,
          doc: u
        }), d = true, (a || c) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), ye(this.query) || pe(this.query))
      for (; r.size > this.query.limit; ) {
        const t3 = ye(this.query) ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      Ro: r,
      vo: n,
      Bn: o,
      mutatedKeys: i
    };
  }
  Vo(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.Ro;
    this.Ro = t2.Ro, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.vo.no();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return L2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.Ao(t3.doc, e2.doc)), this.So(n);
    const r = e ? this.Do() : [], o = this.Io.size === 0 && this.current ? 1 : 0, a = o !== this.Eo;
    if (this.Eo = o, i.length !== 0 || a) {
      return {
        snapshot: new Bo(this.query, t2.Ro, s, i, t2.mutatedKeys, o === 0, a, false),
        Co: r
      };
    }
    return {
      Co: r
    };
  }
  ro(t2) {
    return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
      Ro: this.Ro,
      vo: new Lo(),
      mutatedKeys: this.mutatedKeys,
      Bn: false
    }, false)) : {
      Co: []
    };
  }
  No(t2) {
    return !this.To.has(t2) && (!!this.Ro.has(t2) && !this.Ro.get(t2).hasLocalMutations);
  }
  So(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this.To = this.To.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this.To = this.To.delete(t3)), this.current = t2.current);
  }
  Do() {
    if (!this.current)
      return [];
    const t2 = this.Io;
    this.Io = Sn(), this.Ro.forEach((t3) => {
      this.No(t3.key) && (this.Io = this.Io.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.Io.has(t3) || e.push(new ta2(t3));
    }), this.Io.forEach((n) => {
      t2.has(n) || e.push(new Zo(n));
    }), e;
  }
  ko(t2) {
    this.To = t2.zn, this.Io = Sn();
    const e = this.bo(t2.documents);
    return this.applyChanges(e, true);
  }
  xo() {
    return Bo.fromInitialDocuments(this.query, this.Ro, this.mutatedKeys, this.Eo === 0);
  }
};
var na2 = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var sa2 = class {
  constructor(t2) {
    this.key = t2, this.$o = false;
  }
};
var ia2 = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.Fo = {}, this.Oo = new Gi((t3) => ve(t3), be), this.Mo = new Map(), this.Lo = new Set(), this.Bo = new gn(St.comparator), this.Uo = new Map(), this.qo = new Vr(), this.Ko = {}, this.jo = new Map(), this.Qo = $i.re(), this.onlineState = "Unknown", this.Wo = void 0;
  }
  get isPrimaryClient() {
    return this.Wo === true;
  }
};
async function ra2(t2, e) {
  const n = xa2(t2);
  let s, i;
  const r = n.Oo.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.xo();
  else {
    const t3 = await pr(n.localStore, Re(e)), r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await oa2(n, e, s, r2 === "current"), n.isPrimaryClient && ho(n.remoteStore, t3);
  }
  return i;
}
async function oa2(t2, e, n, s) {
  t2.Go = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.bo(n3);
    i2.Bn && (i2 = await Er(t3.localStore, e3.query, false).then(({ documents: t4 }) => e3.view.bo(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r2);
    return pa2(t3, e3.targetId, o2.Co), o2.snapshot;
  }(t2, e2, n2, s2);
  const i = await Er(t2.localStore, e, true), r = new ea2(e, i.zn), o = r.bo(i.documents), a = kn.createSynthesizedTargetChangeForCurrentChange(n, s && t2.onlineState !== "Offline"), c = r.applyChanges(o, t2.isPrimaryClient, a);
  pa2(t2, n, c.Co);
  const u = new na2(e, n, r);
  return t2.Oo.set(e, u), t2.Mo.has(n) ? t2.Mo.get(n).push(e) : t2.Mo.set(n, [e]), c.snapshot;
}
async function aa2(t2, e) {
  const n = q2(t2), s = n.Oo.get(e), i = n.Mo.get(s.targetId);
  if (i.length > 1)
    return n.Mo.set(s.targetId, i.filter((t3) => !be(t3, e))), void n.Oo.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await Tr(n.localStore, s.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), lo(n.remoteStore, s.targetId), ga(n, s.targetId);
    }).catch(Bi);
  } else
    ga(n, s.targetId), await Tr(n.localStore, s.targetId, true);
}
async function ca(t2, e, n) {
  const s = $a2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = q2(t4), s2 = at.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), Sn());
      let r;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => n2.Wn.vn(t5, i).next((i2) => {
        r = i2;
        const o = [];
        for (const t6 of e2) {
          const e3 = en(t6, r.get(t6.key));
          e3 != null && o.push(new on(t6.key, e3, Qt(e3.value.mapValue), Je.exists(true)));
        }
        return n2.An.addMutationBatch(t5, s2, o, e2);
      })).then((t5) => (t5.applyToLocalDocumentSet(r), {
        batchId: t5.batchId,
        changes: r
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.Ko[t4.currentUser.toKey()];
      s2 || (s2 = new gn(it));
      s2 = s2.insert(e2, n2), t4.Ko[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await Ia2(s, t3.changes), await Ro(s.remoteStore);
  } catch (t3) {
    const e2 = Oo(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function ua2(t2, e) {
  const n = q2(t2);
  try {
    const t3 = await mr(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.Uo.get(e2);
      s && (B2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.$o = true : t4.modifiedDocuments.size > 0 ? B2(s.$o) : t4.removedDocuments.size > 0 && (B2(s.$o), s.$o = false));
    }), await Ia2(n, t3, e);
  } catch (t3) {
    await Bi(t3);
  }
}
function ha2(t2, e, n) {
  const s = q2(t2);
  if (s.isPrimaryClient && n === 0 || !s.isPrimaryClient && n === 1) {
    const t3 = [];
    s.Oo.forEach((n2, s2) => {
      const i = s2.view.ro(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = q2(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.ro(e2) && (s2 = true);
      }), s2 && Go(n2);
    }(s.eventManager, e), t3.length && s.Fo.Pr(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function la2(t2, e, n) {
  const s = q2(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.Uo.get(e), r = i && i.key;
  if (r) {
    let t3 = new gn(St.comparator);
    t3 = t3.insert(r, Wt.newNoDocument(r, ct.min()));
    const n2 = Sn().add(r), i2 = new Nn(ct.min(), new Map(), new Tn(it), t3, n2);
    await ua2(s, i2), s.Bo = s.Bo.remove(r), s.Uo.delete(e), Ea(s);
  } else
    await Tr(s.localStore, e, false).then(() => ga(s, e, n)).catch(Bi);
}
async function fa2(t2, e) {
  const n = q2(t2), s = e.batch.batchId;
  try {
    const t3 = await wr(n.localStore, e);
    ma2(n, s, null), _a(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await Ia2(n, t3);
  } catch (t3) {
    await Bi(t3);
  }
}
async function da2(t2, e, n) {
  const s = q2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = q2(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2.An.lookupMutationBatch(t5, e2).next((e3) => (B2(e3 !== null), s2 = e3.keys(), n2.An.removeMutationBatch(t5, e3))).next(() => n2.An.performConsistencyCheck(t5)).next(() => n2.Wn.vn(t5, s2));
      });
    }(s.localStore, e);
    ma2(s, e, n), _a(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await Ia2(s, t3);
  } catch (n2) {
    await Bi(n2);
  }
}
async function wa(t2, e) {
  const n = q2(t2);
  go(n.remoteStore) || $("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = q2(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2.An.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (t3 === -1)
      return void e.resolve();
    const s = n.jo.get(t3) || [];
    s.push(e), n.jo.set(t3, s);
  } catch (t3) {
    const n2 = Oo(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function _a(t2, e) {
  (t2.jo.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.jo.delete(e);
}
function ma2(t2, e, n) {
  const s = q2(t2);
  let i = s.Ko[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.Ko[s.currentUser.toKey()] = i;
  }
}
function ga(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.Mo.get(e))
    t2.Oo.delete(s), n && t2.Fo.zo(s, n);
  if (t2.Mo.delete(e), t2.isPrimaryClient) {
    t2.qo.us(e).forEach((e2) => {
      t2.qo.containsKey(e2) || ya2(t2, e2);
    });
  }
}
function ya2(t2, e) {
  t2.Lo.delete(e.path.canonicalString());
  const n = t2.Bo.get(e);
  n !== null && (lo(t2.remoteStore, n), t2.Bo = t2.Bo.remove(e), t2.Uo.delete(n), Ea(t2));
}
function pa2(t2, e, n) {
  for (const s of n)
    if (s instanceof Zo)
      t2.qo.addReference(s.key, e), Ta(t2, s);
    else if (s instanceof ta2) {
      $("SyncEngine", "Document no longer in limbo: " + s.key), t2.qo.removeReference(s.key, e);
      t2.qo.containsKey(s.key) || ya2(t2, s.key);
    } else
      L2();
}
function Ta(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.Bo.get(n) || t2.Lo.has(s) || ($("SyncEngine", "New document in limbo: " + n), t2.Lo.add(s), Ea(t2));
}
function Ea(t2) {
  for (; t2.Lo.size > 0 && t2.Bo.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.Lo.values().next().value;
    t2.Lo.delete(e);
    const n = new St(dt.fromString(e)), s = t2.Qo.next();
    t2.Uo.set(s, new sa2(n)), t2.Bo = t2.Bo.insert(n, s), ho(t2.remoteStore, new ai(Re(ge(n.path)), s, 2, et.I));
  }
}
async function Ia2(t2, e, n) {
  const s = q2(t2), i = [], r = [], o = [];
  s.Oo.isEmpty() || (s.Oo.forEach((t3, a) => {
    o.push(s.Go(a, e, n).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(a.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = ur.$n(a.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.Fo.Pr(i), await async function(t3, e2) {
    const n2 = q2(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => Gs.forEach(e2, (e3) => Gs.forEach(e3.kn, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => Gs.forEach(e3.xn, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!Xs(t4))
        throw t4;
      $("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.qn.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.qn = n2.qn.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function Aa2(t2, e) {
  const n = q2(t2);
  if (!n.currentUser.isEqual(e)) {
    $("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await dr(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.jo.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new j(K2.CANCELLED, e2));
        });
      }), t4.jo.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await Ia2(n, t3.Gn);
  }
}
function Ra2(t2, e) {
  const n = q2(t2), s = n.Uo.get(e);
  if (s && s.$o)
    return Sn().add(s.key);
  {
    let t3 = Sn();
    const s2 = n.Mo.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.Oo.get(e2);
      t3 = t3.unionWith(s3.view.Po);
    }
    return t3;
  }
}
async function Pa(t2, e) {
  const n = q2(t2), s = await Er(n.localStore, e.query, true), i = e.view.ko(s);
  return n.isPrimaryClient && pa2(n, e.targetId, i.Co), i;
}
async function ba2(t2) {
  const e = q2(t2);
  return Ar(e.localStore).then((t3) => Ia2(e, t3));
}
async function va(t2, e, n, s) {
  const i = q2(t2), r = await function(t3, e2) {
    const n2 = q2(t3), s2 = q2(n2.An);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.Zt(t4, e2).next((e3) => e3 ? n2.Wn.vn(t4, e3) : Gs.resolve(null)));
  }(i.localStore, e);
  r !== null ? (n === "pending" ? await Ro(i.remoteStore) : n === "acknowledged" || n === "rejected" ? (ma2(i, e, s || null), _a(i, e), function(t3, e2) {
    q2(q2(t3).An).ee(e2);
  }(i.localStore, e)) : L2(), await Ia2(i, r)) : $("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function Va2(t2, e) {
  const n = q2(t2);
  if (xa2(n), $a2(n), e === true && n.Wo !== true) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await Sa2(n, t3.toArray());
    n.Wo = true, await ko(n.remoteStore, true);
    for (const t4 of e2)
      ho(n.remoteStore, t4);
  } else if (e === false && n.Wo !== false) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.Mo.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (ga(n, i), Tr(n.localStore, i, true))), lo(n.remoteStore, i);
    }), await e2, await Sa2(n, t3), function(t4) {
      const e3 = q2(t4);
      e3.Uo.forEach((t5, n2) => {
        lo(e3.remoteStore, n2);
      }), e3.qo.hs(), e3.Uo = new Map(), e3.Bo = new gn(St.comparator);
    }(n), n.Wo = false, await ko(n.remoteStore, false);
  }
}
async function Sa2(t2, e, n) {
  const s = q2(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.Mo.get(t3);
    if (n2 && n2.length !== 0) {
      e2 = await pr(s.localStore, Re(n2[0]));
      for (const t4 of n2) {
        const e3 = s.Oo.get(t4), n3 = await Pa(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await Ir(s.localStore, t3);
      e2 = await pr(s.localStore, n3), await oa2(s, Da(n3), t3, false);
    }
    i.push(e2);
  }
  return s.Fo.Pr(r), i;
}
function Da(t2) {
  return me(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function Ca2(t2) {
  const e = q2(t2);
  return q2(q2(e.localStore).persistence).Tn();
}
async function Na2(t2, e, n, s) {
  const i = q2(t2);
  if (i.Wo)
    $("SyncEngine", "Ignoring unexpected query state notification.");
  else if (i.Mo.has(e))
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await Ar(i.localStore), s2 = Nn.createSynthesizedRemoteEventForCurrentChange(e, n === "current");
        await Ia2(i, t3, s2);
        break;
      }
      case "rejected":
        await Tr(i.localStore, e, true), ga(i, e, s);
        break;
      default:
        L2();
    }
}
async function ka2(t2, e, n) {
  const s = xa2(t2);
  if (s.Wo) {
    for (const t3 of e) {
      if (s.Mo.has(t3)) {
        $("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await Ir(s.localStore, t3), n2 = await pr(s.localStore, e2);
      await oa2(s, Da(e2), n2.targetId, false), ho(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.Mo.has(t3) && await Tr(s.localStore, t3, false).then(() => {
        lo(s.remoteStore, t3), ga(s, t3);
      }).catch(Bi);
  }
}
function xa2(t2) {
  const e = q2(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = ua2.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = Ra2.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = la2.bind(null, e), e.Fo.Pr = Qo.bind(null, e.eventManager), e.Fo.zo = Wo.bind(null, e.eventManager), e;
}
function $a2(t2) {
  const e = q2(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = fa2.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = da2.bind(null, e), e;
}
function Fa2(t2, e, n) {
  const s = q2(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = q2(t4), s3 = Gn(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3.Ye.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), void n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2));
      n2._updateProgress(Xo(s2));
      const i = new Yo(s2, t3.localStore, e2.k);
      let r = await e2.Ho();
      for (; r; ) {
        const t4 = await i.yo(r);
        t4 && n2._updateProgress(t4), r = await e2.Ho();
      }
      const o = await i.complete();
      await Ia2(t3, o.In, void 0), await function(t4, e3) {
        const n3 = q2(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3.Ye.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress);
    } catch (t4) {
      O2("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4);
    }
  })(s, e, n).then(() => {
    s.sharedClientState.notifyBundleLoaded();
  });
}
var Oa = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.k = to(t2.databaseInfo.databaseId), this.sharedClientState = this.Jo(t2), this.persistence = this.Yo(t2), await this.persistence.start(), this.gcScheduler = this.Xo(t2), this.localStore = this.Zo(t2);
  }
  Xo(t2) {
    return null;
  }
  Zo(t2) {
    return fr(this.persistence, new hr(), t2.initialUser, this.k);
  }
  Yo(t2) {
    return new xr(Fr.ks, this.k);
  }
  Jo(t2) {
    return new Wr();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var Ma2 = class extends Oa {
  constructor(t2, e, n) {
    super(), this.ta = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await Rr(this.localStore), await this.ta.initialize(this, t2), await $a2(this.ta.syncEngine), await Ro(this.ta.remoteStore), await this.persistence.sn(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(this.localStore), Promise.resolve()));
  }
  Zo(t2) {
    return fr(this.persistence, new hr(), t2.initialUser, this.k);
  }
  Xo(t2) {
    const e = this.persistence.referenceDelegate.garbageCollector;
    return new Ki(e, t2.asyncQueue);
  }
  Yo(t2) {
    const e = or(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = this.cacheSizeBytes !== void 0 ? vi.withCacheSize(this.cacheSizeBytes) : vi.DEFAULT;
    return new sr(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, Xr(), Zr(), this.k, this.sharedClientState, !!this.forceOwnership);
  }
  Jo(t2) {
    return new Wr();
  }
};
var La2 = class extends Ma2 {
  constructor(t2, e) {
    super(t2, e, false), this.ta = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.ta.syncEngine;
    this.sharedClientState instanceof Qr && (this.sharedClientState.syncEngine = {
      mi: va.bind(null, e),
      gi: Na2.bind(null, e),
      yi: ka2.bind(null, e),
      Tn: Ca2.bind(null, e),
      _i: ba2.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.sn(async (t3) => {
      await Va2(this.ta.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : t3 || this.gcScheduler.stop());
    });
  }
  Jo(t2) {
    const e = Xr();
    if (!Qr.bt(e))
      throw new j(K2.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = or(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new Qr(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var Ba = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => ha2(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = Aa2.bind(null, this.syncEngine), await ko(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new qo();
  }
  createDatastore(t2) {
    const e = to(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new Yr(s));
    var s;
    return function(t3, e2, n2, s2) {
      return new ro(t3, e2, n2, s2);
    }(t2.authCredentials, t2.appCheckCredentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => ha2(this.syncEngine, t3, 0), r = zr.bt() ? new zr() : new Gr(), new ao(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const a = new ia2(t3, e2, n, s, i, r);
      return o && (a.Wo = true), a;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = q2(t2);
      $("RemoteStore", "RemoteStore shutting down."), e.Gr.add(5), await uo(e), e.Hr.shutdown(), e.Jr.set("Unknown");
    }(this.remoteStore);
  }
};
function Ua2(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var qa2 = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.ea(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.ea(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  na() {
    this.muted = true;
  }
  ea(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var Ka2 = class {
  constructor(t2, e) {
    this.sa = t2, this.k = e, this.metadata = new Q2(), this.buffer = new Uint8Array(), this.ia = new TextDecoder("utf-8"), this.ra().then((t3) => {
      t3 && t3._o() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(t3 == null ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.sa.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async Ho() {
    return await this.getMetadata(), this.ra();
  }
  async ra() {
    const t2 = await this.oa();
    if (t2 === null)
      return null;
    const e = this.ia.decode(t2), n = Number(e);
    isNaN(n) && this.aa(`length string (${e}) is not valid number`);
    const s = await this.ca(n);
    return new Ho(JSON.parse(s), t2.length + n);
  }
  ua() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async oa() {
    for (; this.ua() < 0; ) {
      if (await this.ha())
        break;
    }
    if (this.buffer.length === 0)
      return null;
    const t2 = this.ua();
    t2 < 0 && this.aa("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async ca(t2) {
    for (; this.buffer.length < t2; ) {
      await this.ha() && this.aa("Reached the end of bundle when more is expected.");
    }
    const e = this.ia.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  aa(t2) {
    throw this.sa.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async ha() {
    const t2 = await this.sa.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var ja2 = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new j(K2.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = q2(t3), s = ts(n.k) + "/documents", i = {
        documents: e2.map((t4) => Jn(n.k, t4))
      }, r = await n.ji("BatchGetDocuments", s, i), o = new Map();
      r.forEach((t4) => {
        const e3 = is(n.k, t4);
        o.set(e3.key.toString(), e3);
      });
      const a = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        B2(!!e3), a.push(e3);
      }), a;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new hn(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = St.fromPath(e);
      this.mutations.push(new ln(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = q2(t3), s = ts(n.k) + "/documents", i = {
        writes: e.map((t4) => os(n.k, t4))
      };
      await n.Bi("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw L2();
      e = ct.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new j(K2.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? Je.updateTime(e) : Je.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(ct.min()))
        throw new j(K2.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return Je.updateTime(e);
    }
    return Je.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var Qa = class {
  constructor(t2, e, n, s) {
    this.asyncQueue = t2, this.datastore = e, this.updateFunction = n, this.deferred = s, this.la = 5, this.ur = new eo(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.la -= 1, this.fa();
  }
  fa() {
    this.ur.Zi(async () => {
      const t2 = new ja2(this.datastore), e = this.da(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.wa(t3);
        }));
      }).catch((t3) => {
        this.wa(t3);
      });
    });
  }
  da(t2) {
    try {
      const e = this.updateFunction(t2);
      return !bt(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  wa(t2) {
    this.la > 0 && this._a(t2) ? (this.la -= 1, this.asyncQueue.enqueueAndForget(() => (this.fa(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  _a(t2) {
    if (t2.name === "FirebaseError") {
      const e = t2.code;
      return e === "aborted" || e === "failed-precondition" || !_n(e);
    }
    return false;
  }
};
var Wa2 = class {
  constructor(t2, e, n, s) {
    this.authCredentials = t2, this.appCheckCredentials = e, this.asyncQueue = n, this.databaseInfo = s, this.user = D2.UNAUTHENTICATED, this.clientId = st.A(), this.authCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, async (t3) => {
      $("FirestoreClient", "Received user=", t3.uid), await this.authCredentialListener(t3), this.user = t3;
    }), this.appCheckCredentials.start(n, () => Promise.resolve());
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.authCredentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new j(K2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new Q2();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t2.resolve();
      } catch (e) {
        const n = Oo(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function Ga2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), $("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await dr(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function za2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await Ha2(t2);
  $("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => async function(t4, e2) {
    const n2 = q2(t4);
    n2.asyncQueue.verifyOperationInProgress(), $("RemoteStore", "RemoteStore received new credentials");
    const s2 = go(n2);
    n2.Gr.add(3), await uo(n2), s2 && n2.Jr.set("Unknown"), await n2.remoteSyncer.handleCredentialChange(e2), n2.Gr.delete(3), await co(n2);
  }(e.remoteStore, t3)), t2.onlineComponents = e;
}
async function Ha2(t2) {
  return t2.offlineComponents || ($("FirestoreClient", "Using default OfflineComponentProvider"), await Ga2(t2, new Oa())), t2.offlineComponents;
}
async function Ja2(t2) {
  return t2.onlineComponents || ($("FirestoreClient", "Using default OnlineComponentProvider"), await za2(t2, new Ba())), t2.onlineComponents;
}
function Ya2(t2) {
  return Ha2(t2).then((t3) => t3.persistence);
}
function Xa2(t2) {
  return Ha2(t2).then((t3) => t3.localStore);
}
function Za2(t2) {
  return Ja2(t2).then((t3) => t3.remoteStore);
}
function tc2(t2) {
  return Ja2(t2).then((t3) => t3.syncEngine);
}
async function ec2(t2) {
  const e = await Ja2(t2), n = e.eventManager;
  return n.onListen = ra2.bind(null, e.syncEngine), n.onUnlisten = aa2.bind(null, e.syncEngine), n;
}
function nc2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Ya2(t2), n = await Za2(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = q2(t3);
      return e2.Gr.delete(0), co(e2);
    }(n);
  });
}
function sc2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Ya2(t2), n = await Za2(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = q2(t3);
      e2.Gr.add(0), await uo(e2), e2.Jr.set("Offline");
    }(n);
  });
}
function ic2(t2, e) {
  const n = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = q2(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.Wn.Rn(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new j(K2.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = Oo(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await Xa2(t2), e, n)), n.promise;
}
function rc2(t2, e, n = {}) {
  const s = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new qa2({
      next: (r2) => {
        e2.enqueueAndForget(() => jo(t3, o));
        const a = r2.docs.has(n2);
        !a && r2.fromCache ? i.reject(new j(K2.UNAVAILABLE, "Failed to get document because the client is offline.")) : a && r2.fromCache && s2 && s2.source === "server" ? i.reject(new j(K2.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new zo(ge(n2.path), r, {
      includeMetadataChanges: true,
      wo: true
    });
    return Ko(t3, o);
  }(await ec2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function oc2(t2, e) {
  const n = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await Er(t3, e2, true), i = new ea2(e2, s.zn), r = i.bo(s.documents), o = i.applyChanges(r, false);
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = Oo(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await Xa2(t2), e, n)), n.promise;
}
function ac2(t2, e, n = {}) {
  const s = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new qa2({
      next: (n3) => {
        e2.enqueueAndForget(() => jo(t3, o)), n3.fromCache && s2.source === "server" ? i.reject(new j(K2.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new zo(n2, r, {
      includeMetadataChanges: true,
      wo: true
    });
    return Ko(t3, o);
  }(await ec2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function cc2(t2, e) {
  const n = new qa2(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    q2(t3).io.add(e2), e2.next();
  }(await ec2(t2), n)), () => {
    n.na(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      q2(t3).io.delete(e2);
    }(await ec2(t2), n));
  };
}
function uc2(t2, e) {
  const n = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const s = await function(t3) {
      return Ja2(t3).then((t4) => t4.datastore);
    }(t2);
    new Qa(t2.asyncQueue, s, e, n).run();
  }), n.promise;
}
function hc2(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = typeof t3 == "string" ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new Ka2(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return Ua2(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return Ua2(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, to(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    Fa2(await tc2(t2), i, s);
  });
}
function lc2(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = q2(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n.Ye.getNamedQuery(t4, e2));
  }(await Xa2(t2), e));
}
var fc2 = class {
  constructor(t2, e, n, s, i, r, o, a) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = a;
  }
};
var dc2 = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t2) {
    return t2 instanceof dc2 && t2.projectId === this.projectId && t2.database === this.database;
  }
};
var wc2 = new Map();
function _c(t2, e, n) {
  if (!n)
    throw new j(K2.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function mc2(t2, e, n, s) {
  if (e === true && s === true)
    throw new j(K2.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function gc2(t2) {
  if (!St.isDocumentKey(t2))
    throw new j(K2.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function yc2(t2) {
  if (St.isDocumentKey(t2))
    throw new j(K2.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function pc2(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor)
          return t3.constructor.name;
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : L2();
}
function Tc2(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new j(K2.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = pc2(t2);
      throw new j(K2.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function Ec2(t2, e) {
  if (e <= 0)
    throw new j(K2.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var Ic2 = class {
  constructor(t2) {
    var e;
    if (t2.host === void 0) {
      if (t2.ssl !== void 0)
        throw new j(K2.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
        throw new j(K2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, mc2("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var Ac2 = class {
  constructor(t2, e, n) {
    this._authCredentials = e, this._appCheckCredentials = n, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new Ic2({}), this._settingsFrozen = false, t2 instanceof dc2 ? this._databaseId = t2 : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new j(K2.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new dc2(t3.options.projectId);
    }(t2));
  }
  get app() {
    if (!this._app)
      throw new j(K2.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new j(K2.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new Ic2(t2), t2.credentials !== void 0 && (this._authCredentials = function(t3) {
      if (!t3)
        return new G();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return B2(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new Y2(e, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new j(K2.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = wc2.get(t2);
      e && ($("ComponentProvider", "Removing Datastore"), wc2.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function Rc2(t2, e, n, s = {}) {
  var i;
  const r = (t2 = Tc2(t2, Ac2))._getSettings();
  if (r.host !== "firestore.googleapis.com" && r.host !== e && O2("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if (typeof s.mockUserToken == "string")
      e2 = s.mockUserToken, n2 = D2.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, (i = t2._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new j(K2.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new D2(r2);
    }
    t2._authCredentials = new z2(new W2(e2, n2));
  }
}
var Pc2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new vc2(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new Pc2(this.firestore, t2, this._key);
  }
};
var bc2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new bc2(this.firestore, t2, this._query);
  }
};
var vc2 = class extends bc2 {
  constructor(t2, e, n) {
    super(t2, e, ge(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new Pc2(this.firestore, null, new St(t2));
  }
  withConverter(t2) {
    return new vc2(this.firestore, t2, this._path);
  }
};
function Vc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), _c("collection", "path", e), t2 instanceof Ac2) {
    const s = dt.fromString(e, ...n);
    return yc2(s), new vc2(t2, null, s);
  }
  {
    if (!(t2 instanceof Pc2 || t2 instanceof vc2))
      throw new j(K2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(dt.fromString(e, ...n));
    return yc2(s), new vc2(t2.firestore, null, s);
  }
}
function Sc2(t2, e) {
  if (t2 = Tc2(t2, Ac2), _c("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new j(K2.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new bc2(t2, null, function(t3) {
    return new _e(dt.emptyPath(), t3);
  }(e));
}
function Dc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = st.A()), _c("doc", "path", e), t2 instanceof Ac2) {
    const s = dt.fromString(e, ...n);
    return gc2(s), new Pc2(t2, null, new St(s));
  }
  {
    if (!(t2 instanceof Pc2 || t2 instanceof vc2))
      throw new j(K2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(dt.fromString(e, ...n));
    return gc2(s), new Pc2(t2.firestore, t2 instanceof vc2 ? t2.converter : null, new St(s));
  }
}
function Cc2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof Pc2 || t2 instanceof vc2) && (e instanceof Pc2 || e instanceof vc2) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function Nc2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof bc2 && e instanceof bc2 && (t2.firestore === e.firestore && be(t2._query, e._query) && t2.converter === e.converter);
}
var kc2 = class {
  constructor() {
    this.ma = Promise.resolve(), this.ga = [], this.ya = false, this.pa = [], this.Ta = null, this.Ea = false, this.Ia = false, this.Aa = [], this.ur = new eo(this, "async_queue_retry"), this.Ra = () => {
      const t3 = Zr();
      t3 && $("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.ur.er();
    };
    const t2 = Zr();
    t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.Ra);
  }
  get isShuttingDown() {
    return this.ya;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Pa(), this.ba(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.ya) {
      this.ya = true, this.Ia = t2 || false;
      const e = Zr();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.Ra);
    }
  }
  enqueue(t2) {
    if (this.Pa(), this.ya)
      return new Promise(() => {
      });
    const e = new Q2();
    return this.ba(() => this.ya && this.Ia ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.ga.push(t2), this.va()));
  }
  async va() {
    if (this.ga.length !== 0) {
      try {
        await this.ga[0](), this.ga.shift(), this.ur.reset();
      } catch (t2) {
        if (!Xs(t2))
          throw t2;
        $("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.ga.length > 0 && this.ur.Zi(() => this.va());
    }
  }
  ba(t2) {
    const e = this.ma.then(() => (this.Ea = true, t2().catch((t3) => {
      this.Ta = t3, this.Ea = false;
      const e2 = function(t4) {
        let e3 = t4.message || "";
        t4.stack && (e3 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e3;
      }(t3);
      throw F2("INTERNAL UNHANDLED ERROR: ", e2), t3;
    }).then((t3) => (this.Ea = false, t3))));
    return this.ma = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.Pa(), this.Aa.indexOf(t2) > -1 && (e = 0);
    const s = Fo.createAndSchedule(this, t2, e, n, (t3) => this.Va(t3));
    return this.pa.push(s), s;
  }
  Pa() {
    this.Ta && L2();
  }
  verifyOperationInProgress() {
  }
  async Sa() {
    let t2;
    do {
      t2 = this.ma, await t2;
    } while (t2 !== this.ma);
  }
  Da(t2) {
    for (const e of this.pa)
      if (e.timerId === t2)
        return true;
    return false;
  }
  Ca(t2) {
    return this.Sa().then(() => {
      this.pa.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this.pa)
        if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
          break;
      return this.Sa();
    });
  }
  Na(t2) {
    this.Aa.push(t2);
  }
  Va(t2) {
    const e = this.pa.indexOf(t2);
    this.pa.splice(e, 1);
  }
};
function xc2(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && typeof n[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var $c2 = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new Q2(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var Fc2 = -1;
var Oc2 = class extends Ac2 {
  constructor(t2, e, n) {
    super(t2, e, n), this.type = "firestore", this._queue = new kc2(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || Uc2(this), this._firestoreClient.terminate();
  }
};
function Mc2(t2, e) {
  const n = _getProvider(t2, "firestore");
  if (n.isInitialized()) {
    const t3 = n.getImmediate(), s = n.getOptions();
    if (deepEqual(s, e))
      return t3;
    throw new j(K2.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
  }
  if (e.cacheSizeBytes !== void 0 && e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
    throw new j(K2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return n.initialize({
    options: e
  });
}
function Lc2(e = getApp()) {
  return _getProvider(e, "firestore").getImmediate();
}
function Bc2(t2) {
  return t2._firestoreClient || Uc2(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function Uc2(t2) {
  var e;
  const n = t2._freezeSettings(), s = function(t3, e2, n2, s2) {
    return new fc2(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new Wa2(t2._authCredentials, t2._appCheckCredentials, t2._queue, s);
}
function qc2(t2, e) {
  Xc2(t2 = Tc2(t2, Oc2));
  const n = Bc2(t2), s = t2._freezeSettings(), i = new Ba();
  return jc2(n, i, new Ma2(i, s.cacheSizeBytes, e == null ? void 0 : e.forceOwnership));
}
function Kc2(t2) {
  Xc2(t2 = Tc2(t2, Oc2));
  const e = Bc2(t2), n = t2._freezeSettings(), s = new Ba();
  return jc2(e, s, new La2(s, n.cacheSizeBytes));
}
function jc2(t2, e, n) {
  const s = new Q2();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await Ga2(t2, n), await za2(t2, e), s.resolve();
    } catch (t3) {
      if (!function(t4) {
        if (t4.name === "FirebaseError")
          return t4.code === K2.FAILED_PRECONDITION || t4.code === K2.UNIMPLEMENTED;
        if (typeof DOMException != "undefined" && t4 instanceof DOMException)
          return t4.code === 22 || t4.code === 20 || t4.code === 11;
        return true;
      }(t3))
        throw t3;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + t3), s.reject(t3);
    }
  }).then(() => s.promise);
}
function Qc2(t2) {
  if (t2._initialized && !t2._terminated)
    throw new j(K2.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new Q2();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!Hs.bt())
          return Promise.resolve();
        const e2 = t3 + "main";
        await Hs.delete(e2);
      }(or(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function Wc2(t2) {
  return function(t3) {
    const e = new Q2();
    return t3.asyncQueue.enqueueAndForget(async () => wa(await tc2(t3), e)), e.promise;
  }(Bc2(t2 = Tc2(t2, Oc2)));
}
function Gc2(t2) {
  return nc2(Bc2(t2 = Tc2(t2, Oc2)));
}
function zc2(t2) {
  return sc2(Bc2(t2 = Tc2(t2, Oc2)));
}
function Hc2(t2) {
  return _removeServiceInstance(t2.app, "firestore"), t2._delete();
}
function Jc2(t2, e) {
  const n = Bc2(t2 = Tc2(t2, Oc2)), s = new $c2();
  return hc2(n, t2._databaseId, e, s), s;
}
function Yc2(t2, e) {
  return lc2(Bc2(t2 = Tc2(t2, Oc2)), e).then((e2) => e2 ? new bc2(t2, null, e2.query) : null);
}
function Xc2(t2) {
  if (t2._initialized || t2._terminated)
    throw new j(K2.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var Zc2 = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (t2[e].length === 0)
        throw new j(K2.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new _t(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
function tu() {
  return new Zc2("__name__");
}
var eu = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new eu(yt.fromBase64String(t2));
    } catch (t3) {
      throw new j(K2.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new eu(yt.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var nu = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var su = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new j(K2.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new j(K2.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return it(this._lat, t2._lat) || it(this._long, t2._long);
  }
};
var iu = /^__.*__$/;
var ru = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return this.fieldMask !== null ? new on(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new rn(t2, this.data, e, this.fieldTransforms);
  }
};
var ou = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new on(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function au(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw L2();
  }
}
var cu = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.k = n, this.ignoreUndefinedProperties = s, i === void 0 && this.ka(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get xa() {
    return this.settings.xa;
  }
  $a(t2) {
    return new cu(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.k, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Fa(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.$a({
      path: n,
      Oa: false
    });
    return s.Ma(t2), s;
  }
  La(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.$a({
      path: n,
      Oa: false
    });
    return s.ka(), s;
  }
  Ba(t2) {
    return this.$a({
      path: void 0,
      Oa: true
    });
  }
  Ua(t2) {
    return Vu(t2, this.settings.methodName, this.settings.qa || false, this.path, this.settings.Ka);
  }
  contains(t2) {
    return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
  }
  ka() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.Ma(this.path.get(t2));
  }
  Ma(t2) {
    if (t2.length === 0)
      throw this.Ua("Document fields must not be empty");
    if (au(this.xa) && iu.test(t2))
      throw this.Ua('Document fields cannot begin and end with "__"');
  }
};
var uu = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.k = n || to(t2);
  }
  ja(t2, e, n, s = false) {
    return new cu({
      xa: t2,
      methodName: e,
      Ka: n,
      path: _t.emptyPath(),
      Oa: false,
      qa: s
    }, this.databaseId, this.k, this.ignoreUndefinedProperties);
  }
};
function hu(t2) {
  const e = t2._freezeSettings(), n = to(t2._databaseId);
  return new uu(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function lu(t2, e, n, s, i, r = {}) {
  const o = t2.ja(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  Ru("Data must be an object, but it was:", o, s);
  const a = Iu(s, o);
  let c, u;
  if (r.merge)
    c = new mt(o.fieldMask), u = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = Pu(e, s2, n);
      if (!o.contains(i2))
        throw new j(K2.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      Su(t3, i2) || t3.push(i2);
    }
    c = new mt(t3), u = o.fieldTransforms.filter((t4) => c.covers(t4.field));
  } else
    c = null, u = o.fieldTransforms;
  return new ru(new jt(a), c, u);
}
var fu = class extends nu {
  _toFieldTransform(t2) {
    if (t2.xa !== 2)
      throw t2.xa === 1 ? t2.Ua(`${this._methodName}() can only appear at the top level of your update data`) : t2.Ua(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof fu;
  }
};
function du(t2, e, n) {
  return new cu({
    xa: 3,
    Ka: e.settings.Ka,
    methodName: t2._methodName,
    Oa: n
  }, e.databaseId, e.k, e.ignoreUndefinedProperties);
}
var wu = class extends nu {
  _toFieldTransform(t2) {
    return new Ge(t2.path, new Le());
  }
  isEqual(t2) {
    return t2 instanceof wu;
  }
};
var _u = class extends nu {
  constructor(t2, e) {
    super(t2), this.Qa = e;
  }
  _toFieldTransform(t2) {
    const e = du(this, t2, true), n = this.Qa.map((t3) => Eu(t3, e)), s = new Be(n);
    return new Ge(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var mu = class extends nu {
  constructor(t2, e) {
    super(t2), this.Qa = e;
  }
  _toFieldTransform(t2) {
    const e = du(this, t2, true), n = this.Qa.map((t3) => Eu(t3, e)), s = new qe(n);
    return new Ge(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var gu = class extends nu {
  constructor(t2, e) {
    super(t2), this.Wa = e;
  }
  _toFieldTransform(t2) {
    const e = new je(t2.k, xe(t2.k, this.Wa));
    return new Ge(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function yu(t2, e, n, s) {
  const i = t2.ja(1, e, n);
  Ru("Data must be an object, but it was:", i, s);
  const r = [], o = jt.empty();
  ht(s, (t3, s2) => {
    const a2 = vu(e, t3, n);
    s2 = getModularInstance(s2);
    const c = i.La(a2);
    if (s2 instanceof fu)
      r.push(a2);
    else {
      const t4 = Eu(s2, c);
      t4 != null && (r.push(a2), o.set(a2, t4));
    }
  });
  const a = new mt(r);
  return new ou(o, a, i.fieldTransforms);
}
function pu(t2, e, n, s, i, r) {
  const o = t2.ja(1, e, n), a = [Pu(e, s, n)], c = [i];
  if (r.length % 2 != 0)
    throw new j(K2.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    a.push(Pu(e, r[t3])), c.push(r[t3 + 1]);
  const u = [], h = jt.empty();
  for (let t3 = a.length - 1; t3 >= 0; --t3)
    if (!Su(u, a[t3])) {
      const e2 = a[t3];
      let n2 = c[t3];
      n2 = getModularInstance(n2);
      const s2 = o.La(e2);
      if (n2 instanceof fu)
        u.push(e2);
      else {
        const t4 = Eu(n2, s2);
        t4 != null && (u.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new mt(u);
  return new ou(h, l2, o.fieldTransforms);
}
function Tu(t2, e, n, s = false) {
  return Eu(n, t2.ja(s ? 4 : 3, e));
}
function Eu(t2, e) {
  if (Au(t2 = getModularInstance(t2)))
    return Ru("Unsupported field value:", e, t2), Iu(t2, e);
  if (t2 instanceof nu)
    return function(t3, e2) {
      if (!au(e2.xa))
        throw e2.Ua(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.Ua(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.Oa && e.xa !== 4)
      throw e.Ua("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = Eu(i, e2.Ba(s));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return xe(e2.k, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = at.fromDate(t3);
      return {
        timestampValue: jn(e2.k, n)
      };
    }
    if (t3 instanceof at) {
      const n = new at(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: jn(e2.k, n)
      };
    }
    if (t3 instanceof su)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof eu)
      return {
        bytesValue: Qn(e2.k, t3._byteString)
      };
    if (t3 instanceof Pc2) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.Ua(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: zn(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.Ua(`Unsupported field value: ${pc2(t3)}`);
  }(t2, e);
}
function Iu(t2, e) {
  const n = {};
  return lt(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : ht(t2, (t3, s) => {
    const i = Eu(s, e.Fa(t3));
    i != null && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function Au(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof at || t2 instanceof su || t2 instanceof eu || t2 instanceof Pc2 || t2 instanceof nu);
}
function Ru(t2, e, n) {
  if (!Au(n) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n)) {
    const s = pc2(n);
    throw s === "an object" ? e.Ua(t2 + " a custom object") : e.Ua(t2 + " " + s);
  }
}
function Pu(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof Zc2)
    return e._internalPath;
  if (typeof e == "string")
    return vu(t2, e);
  throw Vu("Field path arguments must be of type string or FieldPath.", t2, false, void 0, n);
}
var bu = new RegExp("[~\\*/\\[\\]]");
function vu(t2, e, n) {
  if (e.search(bu) >= 0)
    throw Vu(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n);
  try {
    return new Zc2(...e.split("."))._internalPath;
  } catch (s) {
    throw Vu(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n);
  }
}
function Vu(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = i !== void 0;
  let a = `Function ${e}() called with invalid data`;
  n && (a += " (via `toFirestore()`)"), a += ". ";
  let c = "";
  return (r || o) && (c += " (found", r && (c += ` in field ${s}`), o && (c += ` in document ${i}`), c += ")"), new j(K2.INVALID_ARGUMENT, a + t2 + c);
}
function Su(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var Du = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new Pc2(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new Cu(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(Nu("DocumentSnapshot.get", t2));
      if (e !== null)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var Cu = class extends Du {
  data() {
    return super.data();
  }
};
function Nu(t2, e) {
  return typeof e == "string" ? vu(t2, e) : e instanceof Zc2 ? e._internalPath : e._delegate._internalPath;
}
var ku = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var xu = class extends Du {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new $u(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(Nu("DocumentSnapshot.get", t2));
      if (n !== null)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var $u = class extends xu {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var Fu = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new ku(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return this.size === 0;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new $u(this._firestore, this._userDataWriter, n.key, n, new ku(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new j(K2.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new $u(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new ku(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
          const s = new $u(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new ku(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return e3.type !== 0 && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), e3.type !== 1 && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: Ou(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function Ou(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return L2();
  }
}
function Mu(t2, e) {
  return t2 instanceof xu && e instanceof xu ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (t2._document === null ? e._document === null : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof Fu && e instanceof Fu && (t2._firestore === e._firestore && Nc2(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function Lu(t2) {
  if (pe(t2) && t2.explicitOrderBy.length === 0)
    throw new j(K2.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var Bu = class {
};
function Uu(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
var qu = class extends Bu {
  constructor(t2, e, n) {
    super(), this.Ga = t2, this.za = e, this.Ha = n, this.type = "where";
  }
  _apply(t2) {
    const e = hu(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let a;
      if (i.isKeyField()) {
        if (r === "array-contains" || r === "array-contains-any")
          throw new j(K2.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on FieldPath.documentId().`);
        if (r === "in" || r === "not-in") {
          sh(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(nh(s, t3, n3));
          a = {
            arrayValue: {
              values: e3
            }
          };
        } else
          a = nh(s, t3, o);
      } else
        r !== "in" && r !== "not-in" && r !== "array-contains-any" || sh(o, r), a = Tu(n2, e2, o, r === "in" || r === "not-in");
      const c = Zt.create(i, r, a);
      return function(t4, e3) {
        if (e3.V()) {
          const n4 = Ee(t4);
          if (n4 !== null && !n4.isEqual(e3.field))
            throw new j(K2.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = Te(t4);
          s2 !== null && ih(t4, e3.field, s2);
        }
        const n3 = function(t5, e4) {
          for (const n4 of t5.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(t4, function(t5) {
          switch (t5) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (n3 !== null)
          throw n3 === e3.op ? new j(K2.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new j(K2.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t3, c), c;
    }(t2._query, "where", e, t2.firestore._databaseId, this.Ga, this.za, this.Ha);
    return new bc2(t2.firestore, t2.converter, function(t3, e2) {
      const n2 = t3.filters.concat([e2]);
      return new _e(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n2, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n));
  }
};
function Ku(t2, e, n) {
  const s = e, i = Nu("where", t2);
  return new qu(i, s, n);
}
var ju = class extends Bu {
  constructor(t2, e) {
    super(), this.Ga = t2, this.Ja = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (t3.startAt !== null)
        throw new j(K2.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t3.endAt !== null)
        throw new j(K2.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new le(e2, n);
      return function(t4, e3) {
        if (Te(t4) === null) {
          const n2 = Ee(t4);
          n2 !== null && ih(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.Ga, this.Ja);
    return new bc2(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new _e(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function Qu(t2, e = "asc") {
  const n = e, s = Nu("orderBy", t2);
  return new ju(s, n);
}
var Wu = class extends Bu {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Ya = e, this.Xa = n;
  }
  _apply(t2) {
    return new bc2(t2.firestore, t2.converter, Pe(t2._query, this.Ya, this.Xa));
  }
};
function Gu(t2) {
  return Ec2("limit", t2), new Wu("limit", t2, "F");
}
function zu(t2) {
  return Ec2("limitToLast", t2), new Wu("limitToLast", t2, "L");
}
var Hu = class extends Bu {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Za = e, this.tc = n;
  }
  _apply(t2) {
    const e = eh(t2, this.type, this.Za, this.tc);
    return new bc2(t2.firestore, t2.converter, function(t3, e2) {
      return new _e(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function Ju(...t2) {
  return new Hu("startAt", t2, true);
}
function Yu(...t2) {
  return new Hu("startAfter", t2, false);
}
var Xu = class extends Bu {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Za = e, this.tc = n;
  }
  _apply(t2) {
    const e = eh(t2, this.type, this.Za, this.tc);
    return new bc2(t2.firestore, t2.converter, function(t3, e2) {
      return new _e(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function Zu(...t2) {
  return new Xu("endBefore", t2, true);
}
function th(...t2) {
  return new Xu("endAt", t2, false);
}
function eh(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof Du)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new j(K2.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of Ae(t3))
        if (n3.field.isKeyField())
          r.push(Ot(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (At(t4))
            throw new j(K2.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t4 === null) {
            const t5 = n3.field.canonicalString();
            throw new j(K2.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new ue(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = hu(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new j(K2.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const a = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const c = i2[r2];
        if (o[r2].field.isKeyField()) {
          if (typeof c != "string")
            throw new j(K2.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof c}`);
          if (!Ie(t3) && c.indexOf("/") !== -1)
            throw new j(K2.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by FieldPath.documentId(), the value passed to ${s2}() must be a plain document ID, but '${c}' contains a slash.`);
          const n3 = t3.path.child(dt.fromString(c));
          if (!St.isDocumentKey(n3))
            throw new j(K2.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by FieldPath.documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new St(n3);
          a.push(Ot(e2, i3));
        } else {
          const t4 = Tu(n2, s2, c);
          a.push(t4);
        }
      }
      return new ue(a, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function nh(t2, e, n) {
  if (typeof (n = getModularInstance(n)) == "string") {
    if (n === "")
      throw new j(K2.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!Ie(e) && n.indexOf("/") !== -1)
      throw new j(K2.INVALID_ARGUMENT, `Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(dt.fromString(n));
    if (!St.isDocumentKey(s))
      throw new j(K2.INVALID_ARGUMENT, `Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return Ot(t2, new St(s));
  }
  if (n instanceof Pc2)
    return Ot(t2, n._key);
  throw new j(K2.INVALID_ARGUMENT, `Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: ${pc2(n)}.`);
}
function sh(t2, e) {
  if (!Array.isArray(t2) || t2.length === 0)
    throw new j(K2.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new j(K2.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function ih(t2, e, n) {
  if (!n.isEqual(e))
    throw new j(K2.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var rh = class {
  convertValue(t2, e = "none") {
    switch (Dt(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return Et(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(It(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw L2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return ht(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new su(Et(t2.latitude), Et(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = Rt(t2);
        return n == null ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(Pt(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = Tt(t2);
    return new at(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = dt.fromString(t2);
    B2(As(n));
    const s = new dc2(n.get(1), n.get(3)), i = new St(n.popFirst(5));
    return s.isEqual(e) || F2(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function oh(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var ah = class extends rh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new eu(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new Pc2(this.firestore, null, e);
  }
};
var ch = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = hu(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = uh(t2, this._firestore), i = oh(s.converter, e, n), r = lu(this._dataReader, "WriteBatch.set", s._key, i, s.converter !== null, n);
    return this._mutations.push(r.toMutation(s._key, Je.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = uh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Zc2 ? pu(this._dataReader, "WriteBatch.update", i._key, e, n, s) : yu(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, Je.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = uh(t2, this._firestore);
    return this._mutations = this._mutations.concat(new hn(e._key, Je.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new j(K2.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function uh(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new j(K2.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function hh(t2) {
  t2 = Tc2(t2, Pc2);
  const e = Tc2(t2.firestore, Oc2);
  return rc2(Bc2(e), t2._key).then((n) => Rh(e, t2, n));
}
var lh = class extends rh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new eu(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new Pc2(this.firestore, null, e);
  }
};
function fh(t2) {
  t2 = Tc2(t2, Pc2);
  const e = Tc2(t2.firestore, Oc2), n = Bc2(e), s = new lh(e);
  return ic2(n, t2._key).then((n2) => new xu(e, s, t2._key, n2, new ku(n2 !== null && n2.hasLocalMutations, true), t2.converter));
}
function dh(t2) {
  t2 = Tc2(t2, Pc2);
  const e = Tc2(t2.firestore, Oc2);
  return rc2(Bc2(e), t2._key, {
    source: "server"
  }).then((n) => Rh(e, t2, n));
}
function wh(t2) {
  t2 = Tc2(t2, bc2);
  const e = Tc2(t2.firestore, Oc2), n = Bc2(e), s = new lh(e);
  return Lu(t2._query), ac2(n, t2._query).then((n2) => new Fu(e, s, t2, n2));
}
function _h(t2) {
  t2 = Tc2(t2, bc2);
  const e = Tc2(t2.firestore, Oc2), n = Bc2(e), s = new lh(e);
  return oc2(n, t2._query).then((n2) => new Fu(e, s, t2, n2));
}
function mh(t2) {
  t2 = Tc2(t2, bc2);
  const e = Tc2(t2.firestore, Oc2), n = Bc2(e), s = new lh(e);
  return ac2(n, t2._query, {
    source: "server"
  }).then((n2) => new Fu(e, s, t2, n2));
}
function gh(t2, e, n) {
  t2 = Tc2(t2, Pc2);
  const s = Tc2(t2.firestore, Oc2), i = oh(t2.converter, e, n);
  return Ah(s, [lu(hu(s), "setDoc", t2._key, i, t2.converter !== null, n).toMutation(t2._key, Je.none())]);
}
function yh(t2, e, n, ...s) {
  t2 = Tc2(t2, Pc2);
  const i = Tc2(t2.firestore, Oc2), r = hu(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof Zc2 ? pu(r, "updateDoc", t2._key, e, n, s) : yu(r, "updateDoc", t2._key, e);
  return Ah(i, [o.toMutation(t2._key, Je.exists(true))]);
}
function ph(t2) {
  return Ah(Tc2(t2.firestore, Oc2), [new hn(t2._key, Je.none())]);
}
function Th(t2, e) {
  const n = Tc2(t2.firestore, Oc2), s = Dc2(t2), i = oh(t2.converter, e);
  return Ah(n, [lu(hu(t2.firestore), "addDoc", s._key, i, t2.converter !== null, {}).toMutation(s._key, Je.exists(false))]).then(() => s);
}
function Eh(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || xc2(e[o]) || (r = e[o], o++);
  const a = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (xc2(e[o])) {
    const t3 = e[o];
    e[o] = (n = t3.next) === null || n === void 0 ? void 0 : n.bind(t3), e[o + 1] = (s = t3.error) === null || s === void 0 ? void 0 : s.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let c, u, h;
  if (t2 instanceof Pc2)
    u = Tc2(t2.firestore, Oc2), h = ge(t2._key.path), c = {
      next: (n2) => {
        e[o] && e[o](Rh(u, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = Tc2(t2, bc2);
    u = Tc2(n2.firestore, Oc2), h = n2._query;
    const s2 = new lh(u);
    c = {
      next: (t3) => {
        e[o] && e[o](new Fu(u, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, Lu(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new qa2(s2), r2 = new zo(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => Ko(await ec2(t3), r2)), () => {
      i2.na(), t3.asyncQueue.enqueueAndForget(async () => jo(await ec2(t3), r2));
    };
  }(Bc2(u), h, a, c);
}
function Ih(t2, e) {
  return cc2(Bc2(t2 = Tc2(t2, Oc2)), xc2(e) ? e : {
    next: e
  });
}
function Ah(t2, e) {
  return function(t3, e2) {
    const n = new Q2();
    return t3.asyncQueue.enqueueAndForget(async () => ca(await tc2(t3), e2, n)), n.promise;
  }(Bc2(t2), e);
}
function Rh(t2, e, n) {
  const s = n.docs.get(e._key), i = new lh(t2);
  return new xu(t2, i, e._key, s, new ku(n.hasPendingWrites, n.fromCache), e.converter);
}
var Ph = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = hu(t2);
  }
  get(t2) {
    const e = uh(t2, this._firestore), n = new ah(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || t3.length !== 1)
        return L2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new Du(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new Du(this._firestore, n, e._key, null, e.converter);
      throw L2();
    });
  }
  set(t2, e, n) {
    const s = uh(t2, this._firestore), i = oh(s.converter, e, n), r = lu(this._dataReader, "Transaction.set", s._key, i, s.converter !== null, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = uh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Zc2 ? pu(this._dataReader, "Transaction.update", i._key, e, n, s) : yu(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = uh(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = uh(t2, this._firestore), n = new lh(this._firestore);
    return super.get(t2).then((t3) => new xu(this._firestore, n, e._key, t3._document, new ku(false, false), e.converter));
  }
};
function bh(t2, e) {
  return uc2(Bc2(t2 = Tc2(t2, Oc2)), (n) => e(new Ph(t2, n)));
}
function vh() {
  return new fu("deleteField");
}
function Vh() {
  return new wu("serverTimestamp");
}
function Sh(...t2) {
  return new _u("arrayUnion", t2);
}
function Dh(...t2) {
  return new mu("arrayRemove", t2);
}
function Ch(t2) {
  return new gu("increment", t2);
}
function Nh(t2) {
  return Bc2(t2 = Tc2(t2, Oc2)), new ch(t2, (e) => Ah(t2, e));
}
!function(t2, e = true) {
  !function(t3) {
    C2 = t3;
  }(SDK_VERSION), _registerComponent(new Component("firestore", (t3, { options: n }) => {
    const s = t3.getProvider("app").getImmediate(), i = new Oc2(s, new H2(t3.getProvider("auth-internal")), new Z2(t3.getProvider("app-check-internal")));
    return n = Object.assign({
      useFetchStreams: e
    }, n), i._setSettings(n), i;
  }, "PUBLIC")), registerVersion(S2, "3.4.1", t2), registerVersion(S2, "3.4.1", "esm2017");
}();
export {
  rh as AbstractUserDataWriter,
  eu as Bytes,
  Fc2 as CACHE_SIZE_UNLIMITED,
  vc2 as CollectionReference,
  Pc2 as DocumentReference,
  xu as DocumentSnapshot,
  Zc2 as FieldPath,
  nu as FieldValue,
  Oc2 as Firestore,
  j as FirestoreError,
  su as GeoPoint,
  $c2 as LoadBundleTask,
  bc2 as Query,
  Bu as QueryConstraint,
  $u as QueryDocumentSnapshot,
  Fu as QuerySnapshot,
  ku as SnapshotMetadata,
  at as Timestamp,
  Ph as Transaction,
  ch as WriteBatch,
  dc2 as _DatabaseId,
  St as _DocumentKey,
  tt as _EmptyAppCheckTokenProvider,
  G as _EmptyAuthCredentialsProvider,
  _t as _FieldPath,
  Tc2 as _cast,
  U2 as _debugAssert,
  gt as _isBase64Available,
  O2 as _logWarn,
  mc2 as _validateIsNotUsedTogether,
  Th as addDoc,
  Dh as arrayRemove,
  Sh as arrayUnion,
  Qc2 as clearIndexedDbPersistence,
  Vc2 as collection,
  Sc2 as collectionGroup,
  Rc2 as connectFirestoreEmulator,
  ph as deleteDoc,
  vh as deleteField,
  zc2 as disableNetwork,
  Dc2 as doc,
  tu as documentId,
  qc2 as enableIndexedDbPersistence,
  Kc2 as enableMultiTabIndexedDbPersistence,
  Gc2 as enableNetwork,
  th as endAt,
  Zu as endBefore,
  Bc2 as ensureFirestoreConfigured,
  Ah as executeWrite,
  hh as getDoc,
  fh as getDocFromCache,
  dh as getDocFromServer,
  wh as getDocs,
  _h as getDocsFromCache,
  mh as getDocsFromServer,
  Lc2 as getFirestore,
  Ch as increment,
  Mc2 as initializeFirestore,
  Gu as limit,
  zu as limitToLast,
  Jc2 as loadBundle,
  Yc2 as namedQuery,
  Eh as onSnapshot,
  Ih as onSnapshotsInSync,
  Qu as orderBy,
  Uu as query,
  Nc2 as queryEqual,
  Cc2 as refEqual,
  bh as runTransaction,
  Vh as serverTimestamp,
  gh as setDoc,
  x2 as setLogLevel,
  Mu as snapshotEqual,
  Yu as startAfter,
  Ju as startAt,
  Hc2 as terminate,
  yh as updateDoc,
  Wc2 as waitForPendingWrites,
  Ku as where,
  Nh as writeBatch
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=firebase_firestore.js.map
